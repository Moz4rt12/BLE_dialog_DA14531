<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DA14535 SDK6: I2C</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">DA14535 SDK6
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#files">Files</a> &#124;
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">I2C<div class="ingroups"><a class="el" href="group___drivers.html">Drivers</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>I2C driver API.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="files"></a>
Files</h2></td></tr>
<tr class="memitem:i2c_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c_8h.html">i2c.h</a></td></tr>
<tr class="memdesc:i2c_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definition of API for the I2C Low Level Driver for DA14585, DA14586 and DA14531 devices. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structi2c__t.html">i2c_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C registers (@ 0x50001300)  <a href="structi2c__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structi2c__cfg__t.html">i2c_cfg_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C configuration.  <a href="structi2c__cfg__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga27e69e4d2343eb297877e1894ff2df34"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga27e69e4d2343eb297877e1894ff2df34">i2c_interrupt_cb_t</a>) (uint16_t mask)</td></tr>
<tr class="memdesc:ga27e69e4d2343eb297877e1894ff2df34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback called on interrupt from I2C controller.  <a href="#ga27e69e4d2343eb297877e1894ff2df34">More...</a><br /></td></tr>
<tr class="separator:ga27e69e4d2343eb297877e1894ff2df34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga678dc6024a1d54d4709c78d5e64e9974"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga678dc6024a1d54d4709c78d5e64e9974">i2c_complete_cb_t</a>) (void *cb_data, uint16_t len, bool success)</td></tr>
<tr class="memdesc:ga678dc6024a1d54d4709c78d5e64e9974"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback called upon completion of read or write in non-blocking mode (FIFO or DMA)  <a href="#ga678dc6024a1d54d4709c78d5e64e9974">More...</a><br /></td></tr>
<tr class="separator:ga678dc6024a1d54d4709c78d5e64e9974"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga61dadd085c1777f559549e05962b2c9e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <a class="el" href="group___i2_c.html#gga61dadd085c1777f559549e05962b2c9ea73a0b58cd5b685a9a417c09cc4dd1129">I2C_F_NONE</a> = 0x00000000, 
<a class="el" href="group___i2_c.html#gga61dadd085c1777f559549e05962b2c9eadfe3b147312a9af12b252fe79e0920ae">I2C_F_WAIT_FOR_STOP</a> = 0x00000001, 
<a class="el" href="group___i2_c.html#gga61dadd085c1777f559549e05962b2c9eab37107388b51bbb77fab6bf7e88bcc2e">I2C_F_ADD_STOP</a> = 0x00000002
 }</td></tr>
<tr class="memdesc:ga61dadd085c1777f559549e05962b2c9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flags passed to master transmit/receive operations.  <a href="group___i2_c.html#ga61dadd085c1777f559549e05962b2c9e">More...</a><br /></td></tr>
<tr class="separator:ga61dadd085c1777f559549e05962b2c9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga489a90df00c3703b26d667dbe952b34a"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga489a90df00c3703b26d667dbe952b34a">i2c_clock_t</a> { <a class="el" href="group___i2_c.html#gga489a90df00c3703b26d667dbe952b34aa8e75b80c278d06a0e01bcb8299cb08a2">I2C_CLOCK_DISABLE</a> = 0, 
<a class="el" href="group___i2_c.html#gga489a90df00c3703b26d667dbe952b34aa1b6aa61a115f3461981fd9e6e3d105ea">I2C_CLOCK_ENABLE</a> = 1
 }</td></tr>
<tr class="memdesc:ga489a90df00c3703b26d667dbe952b34a"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C clock status.  <a href="group___i2_c.html#ga489a90df00c3703b26d667dbe952b34a">More...</a><br /></td></tr>
<tr class="separator:ga489a90df00c3703b26d667dbe952b34a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5bdf6025825018e3fb3ed40081433879"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga5bdf6025825018e3fb3ed40081433879">i2c_controller_t</a> { <a class="el" href="group___i2_c.html#gga5bdf6025825018e3fb3ed40081433879a036b0230672b1f4d8de2d2c7ec0c3f97">I2C_CONTROLLER_DISABLE</a> = 0, 
<a class="el" href="group___i2_c.html#gga5bdf6025825018e3fb3ed40081433879a09a8d4a24957d65cb2acbccc69ae1da5">I2C_CONTROLLER_ENABLE</a> = 1
 }</td></tr>
<tr class="memdesc:ga5bdf6025825018e3fb3ed40081433879"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C controller status.  <a href="group___i2_c.html#ga5bdf6025825018e3fb3ed40081433879">More...</a><br /></td></tr>
<tr class="separator:ga5bdf6025825018e3fb3ed40081433879"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac1e2996ebee909590af8e3cc1c316c25"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#gac1e2996ebee909590af8e3cc1c316c25">i2c_mode_t</a> { <a class="el" href="group___i2_c.html#ggac1e2996ebee909590af8e3cc1c316c25a10a3fafafb52ab45984aa5d5a17171a0">I2C_MODE_SLAVE</a> = 0, 
<a class="el" href="group___i2_c.html#ggac1e2996ebee909590af8e3cc1c316c25a166443f9a57684d8e4970f28a7acf982">I2C_MODE_MASTER</a> = 1
 }</td></tr>
<tr class="memdesc:gac1e2996ebee909590af8e3cc1c316c25"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C role.  <a href="group___i2_c.html#gac1e2996ebee909590af8e3cc1c316c25">More...</a><br /></td></tr>
<tr class="separator:gac1e2996ebee909590af8e3cc1c316c25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf7bd376b040c7c04820bdc6abf3a9a7c"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#gaf7bd376b040c7c04820bdc6abf3a9a7c">i2c_restart_t</a> { <a class="el" href="group___i2_c.html#ggaf7bd376b040c7c04820bdc6abf3a9a7cacfa27355e82bc9eabf540a36a80a61a1">I2C_RESTART_DISABLE</a> = 0, 
<a class="el" href="group___i2_c.html#ggaf7bd376b040c7c04820bdc6abf3a9a7cafcc6472d4ef868efbe6ad0096e8c8f5c">I2C_RESTART_ENABLE</a> = 1
 }</td></tr>
<tr class="memdesc:gaf7bd376b040c7c04820bdc6abf3a9a7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restart condition.  <a href="group___i2_c.html#gaf7bd376b040c7c04820bdc6abf3a9a7c">More...</a><br /></td></tr>
<tr class="separator:gaf7bd376b040c7c04820bdc6abf3a9a7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga65b8e8a3eb198a1aa5fac5639a46e8cb"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga65b8e8a3eb198a1aa5fac5639a46e8cb">i2c_addressing_t</a> { <a class="el" href="group___i2_c.html#gga65b8e8a3eb198a1aa5fac5639a46e8cba331406fb33a11a88f96e3ad651bcdb94">I2C_ADDRESSING_7B</a> = 0, 
<a class="el" href="group___i2_c.html#gga65b8e8a3eb198a1aa5fac5639a46e8cba40ae4354c30d2f71caf008b7f40ecb4a">I2C_ADDRESSING_10B</a> = 1
 }</td></tr>
<tr class="memdesc:ga65b8e8a3eb198a1aa5fac5639a46e8cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C addressing mode.  <a href="group___i2_c.html#ga65b8e8a3eb198a1aa5fac5639a46e8cb">More...</a><br /></td></tr>
<tr class="separator:ga65b8e8a3eb198a1aa5fac5639a46e8cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e6a870f98abb8cffa95373b69fb8243"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga6e6a870f98abb8cffa95373b69fb8243">i2c_speed_t</a> { <a class="el" href="group___i2_c.html#gga6e6a870f98abb8cffa95373b69fb8243a5fdea09fb218ae643bca0188d49f11b4">I2C_SPEED_STANDARD</a> = 1, 
<a class="el" href="group___i2_c.html#gga6e6a870f98abb8cffa95373b69fb8243a8dc6cae939d20d56a78d123365caa4ca">I2C_SPEED_FAST</a> = 0
 }</td></tr>
<tr class="memdesc:ga6e6a870f98abb8cffa95373b69fb8243"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C interface speed.  <a href="group___i2_c.html#ga6e6a870f98abb8cffa95373b69fb8243">More...</a><br /></td></tr>
<tr class="separator:ga6e6a870f98abb8cffa95373b69fb8243"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga726ca809ffd3d67ab4b8476646f26635"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <br />
&#160;&#160;<a class="el" href="group___i2_c.html#gga726ca809ffd3d67ab4b8476646f26635ae8ff2a4b8c47cb9bfc8f5ab2aa62f957">I2C_INT_RX_UNDERFLOW</a> = RX_UNDER, 
<a class="el" href="group___i2_c.html#gga726ca809ffd3d67ab4b8476646f26635a4c6a06d2d534f85bc39dfefb11efc163">I2C_INT_RX_OVERFLOW</a> = RX_OVER, 
<a class="el" href="group___i2_c.html#gga726ca809ffd3d67ab4b8476646f26635a9c7016b3a3b0b8a6089a974618adc449">I2C_INT_RX_FULL</a> = RX_FULL, 
<a class="el" href="group___i2_c.html#gga726ca809ffd3d67ab4b8476646f26635ae2cf5e4a5847d8c51153500a068e5fc2">I2C_INT_TX_OVERFLOW</a> = TX_OVER, 
<br />
&#160;&#160;<a class="el" href="group___i2_c.html#gga726ca809ffd3d67ab4b8476646f26635a3e8e02efc2dbd9de0c9c4b57b40edf80">I2C_INT_TX_EMPTY</a> = TX_EMPTY, 
<a class="el" href="group___i2_c.html#gga726ca809ffd3d67ab4b8476646f26635a6f0e95fec2151ef498542bf09672d45c">I2C_INT_READ_REQUEST</a> = RD_REQ, 
<a class="el" href="group___i2_c.html#gga726ca809ffd3d67ab4b8476646f26635aefd37bcbaa954703bc69cd3ea10bb4db">I2C_INT_TX_ABORT</a> = TX_ABRT, 
<a class="el" href="group___i2_c.html#gga726ca809ffd3d67ab4b8476646f26635a2d90404de3a89aae73e39f7ab8f39ad8">I2C_INT_RX_DONE</a> = RX_DONE, 
<br />
&#160;&#160;<a class="el" href="group___i2_c.html#gga726ca809ffd3d67ab4b8476646f26635a85a490f4c65aef9551d36f5abfd6c9ef">I2C_INT_ACTIVITY</a> = ACTIVITY, 
<a class="el" href="group___i2_c.html#gga726ca809ffd3d67ab4b8476646f26635aca35bbac8194007368628b12c040cdc1">I2C_INT_STOP_DETECTED</a> = STOP_DET, 
<a class="el" href="group___i2_c.html#gga726ca809ffd3d67ab4b8476646f26635a18caa4e81a85eef565289d1127b90776">I2C_INT_START_DETECTED</a> = START_DET, 
<a class="el" href="group___i2_c.html#gga726ca809ffd3d67ab4b8476646f26635a148ad5d86616cd5032fa2aba45e57864">I2C_INT_GENERAL_CALL</a> = GEN_CALL
<br />
 }</td></tr>
<tr class="memdesc:ga726ca809ffd3d67ab4b8476646f26635"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C interrupt source.  <a href="group___i2_c.html#ga726ca809ffd3d67ab4b8476646f26635">More...</a><br /></td></tr>
<tr class="separator:ga726ca809ffd3d67ab4b8476646f26635"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef40399c7569e3b745df70b86b7107bd"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#gaef40399c7569e3b745df70b86b7107bd">i2c_abort_t</a> { <br />
&#160;&#160;<a class="el" href="group___i2_c.html#ggaef40399c7569e3b745df70b86b7107bda918faa024ec89a730f50dd2d3c3f8b7d">I2C_ABORT_NONE</a> = 0x00, 
<a class="el" href="group___i2_c.html#ggaef40399c7569e3b745df70b86b7107bdaddd3936bf507790fa4762300d6a263f2">I2C_ABORT_7B_ADDR_NO_ACK</a> = ABRT_7B_ADDR_NOACK, 
<a class="el" href="group___i2_c.html#ggaef40399c7569e3b745df70b86b7107bdaad054085f5e053f52cebaa67364a8143">I2C_ABORT_10B_ADDR1_NO_ACK</a> = ABRT_10ADDR1_NOACK, 
<a class="el" href="group___i2_c.html#ggaef40399c7569e3b745df70b86b7107bda48d3156e99d2a8f95a9f1d570d068351">I2C_ABORT_10B_ADDR2_NO_ACK</a> = ABRT_10ADDR2_NOACK, 
<br />
&#160;&#160;<a class="el" href="group___i2_c.html#ggaef40399c7569e3b745df70b86b7107bdaa39b1d93218d6140ab9a9cfdd6a86dbe">I2C_ABORT_TX_DATA_NO_ACK</a> = ABRT_TXDATA_NOACK, 
<a class="el" href="group___i2_c.html#ggaef40399c7569e3b745df70b86b7107bdabd3e3eb13d624dd07a0c8c7ab224c39d">I2C_ABORT_GENERAL_CALL_NO_ACK</a> = ABRT_GCALL_NOACK, 
<a class="el" href="group___i2_c.html#ggaef40399c7569e3b745df70b86b7107bdafe704623b449c9ac4db6f341ba41219d">I2C_ABORT_GENERAL_CALL_READ</a> = ABRT_GCALL_READ, 
<a class="el" href="group___i2_c.html#ggaef40399c7569e3b745df70b86b7107bdab01c8a03a9c87ba81cf8ae98b5a205f8">I2C_ABORT_HS_ACKDET</a> = ABRT_HS_ACKDET, 
<br />
&#160;&#160;<a class="el" href="group___i2_c.html#ggaef40399c7569e3b745df70b86b7107bda62fa128de5b4cdf4d7eb9905c6d9f9a3">I2C_ABORT_SBYTE_ACKDET</a> = ABRT_SBYTE_ACKDET, 
<a class="el" href="group___i2_c.html#ggaef40399c7569e3b745df70b86b7107bda8229858e498b5b9bd4132da5e4cea7ab">I2C_ABORT_HS_NORSTRT</a> = ABRT_HS_NORSTRT, 
<a class="el" href="group___i2_c.html#ggaef40399c7569e3b745df70b86b7107bdaf585b3c70137a7145e48ef50c803fa46">I2C_ABORT_10B_READ_NO_RESTART</a> = ABRT_10B_RD_NORSTRT, 
<a class="el" href="group___i2_c.html#ggaef40399c7569e3b745df70b86b7107bdae3495840f1c33d692e915fcb5515fd86">I2C_ABORT_MASTER_DISABLED</a> = ABRT_MASTER_DIS, 
<br />
&#160;&#160;<a class="el" href="group___i2_c.html#ggaef40399c7569e3b745df70b86b7107bda499bbdfa83de4b93c233413a0178790e">I2C_ABORT_ARBITRATION_LOST</a> = ARB_LOST, 
<a class="el" href="group___i2_c.html#ggaef40399c7569e3b745df70b86b7107bda8e3523cb2ea809e22a3d6234a671c322">I2C_ABORT_SLAVE_FLUSH_TX_FIFO</a> = ABRT_SLVFLUSH_TXFIFO, 
<a class="el" href="group___i2_c.html#ggaef40399c7569e3b745df70b86b7107bdaab9c090bfb4ae689730648730a6f3ebf">I2C_ABORT_SLAVE_ARBITRATION_LOST</a> = ABRT_SLV_ARBLOST, 
<a class="el" href="group___i2_c.html#ggaef40399c7569e3b745df70b86b7107bda268f2f7e41168b00e67eebee05eba701">I2C_ABORT_SLAVE_IN_TX</a> = ABRT_SLVRD_INTX, 
<br />
&#160;&#160;<a class="el" href="group___i2_c.html#ggaef40399c7569e3b745df70b86b7107bdad1ca116e4f0db0a96f5b55753db57b11">I2C_ABORT_SW_ERROR</a>
<br />
 }</td></tr>
<tr class="memdesc:gaef40399c7569e3b745df70b86b7107bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C abort source.  <a href="group___i2_c.html#gaef40399c7569e3b745df70b86b7107bd">More...</a><br /></td></tr>
<tr class="separator:gaef40399c7569e3b745df70b86b7107bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac688b2325cca3cdc2d76e35fb7199889"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#gac688b2325cca3cdc2d76e35fb7199889">i2c_dma_transfer_t</a> { <a class="el" href="group___i2_c.html#ggac688b2325cca3cdc2d76e35fb7199889a2d32eea9b8ab106762939e0bb65f6396">I2C_DMA_TRANSFER_WRITE</a> = 0, 
<a class="el" href="group___i2_c.html#ggac688b2325cca3cdc2d76e35fb7199889a538c140bfa79d77185478a9e97732879">I2C_DMA_TRANSFER_MASTER_READ</a> = 1, 
<a class="el" href="group___i2_c.html#ggac688b2325cca3cdc2d76e35fb7199889ab7fbf23e7ef39b1ae42b757a8b424cd1">I2C_DMA_TRANSFER_SLAVE_READ</a> = 2
 }</td></tr>
<tr class="memdesc:gac688b2325cca3cdc2d76e35fb7199889"><td class="mdescLeft">&#160;</td><td class="mdescRight">DMA transfer type.  <a href="group___i2_c.html#gac688b2325cca3cdc2d76e35fb7199889">More...</a><br /></td></tr>
<tr class="separator:gac688b2325cca3cdc2d76e35fb7199889"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3558b2fdf2da82e49c3b523af752b1d9"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga3558b2fdf2da82e49c3b523af752b1d9">i2c_dma_channel_pair_t</a> { <a class="el" href="group___i2_c.html#gga3558b2fdf2da82e49c3b523af752b1d9abba262f3627849fba09fbafba96a8ad4">I2C_DMA_CHANNEL_PAIR_1</a> = 0, 
<a class="el" href="group___i2_c.html#gga3558b2fdf2da82e49c3b523af752b1d9af40f23877f9c37b1ec5f01e703fa07ad">I2C_DMA_CHANNEL_PAIR_2</a> = 2
 }</td></tr>
<tr class="memdesc:ga3558b2fdf2da82e49c3b523af752b1d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">DMA channel-pairs for I2C.  <a href="group___i2_c.html#ga3558b2fdf2da82e49c3b523af752b1d9">More...</a><br /></td></tr>
<tr class="separator:ga3558b2fdf2da82e49c3b523af752b1d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gae55e2a1735c775963b497ddb5d09023a"><td class="memItemLeft" align="right" valign="top">__STATIC_FORCEINLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#gae55e2a1735c775963b497ddb5d09023a">i2c_set_controller_status</a> (<a class="el" href="group___i2_c.html#ga5bdf6025825018e3fb3ed40081433879">i2c_controller_t</a> status)</td></tr>
<tr class="memdesc:gae55e2a1735c775963b497ddb5d09023a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set I2C controller status.  <a href="#gae55e2a1735c775963b497ddb5d09023a">More...</a><br /></td></tr>
<tr class="separator:gae55e2a1735c775963b497ddb5d09023a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf6d63040fb70ea0eba06b7874af86479"><td class="memItemLeft" align="right" valign="top">__STATIC_FORCEINLINE <a class="el" href="group___i2_c.html#ga5bdf6025825018e3fb3ed40081433879">i2c_controller_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#gaf6d63040fb70ea0eba06b7874af86479">i2c_get_controller_status</a> (void)</td></tr>
<tr class="memdesc:gaf6d63040fb70ea0eba06b7874af86479"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get I2C Controller Enable status.  <a href="#gaf6d63040fb70ea0eba06b7874af86479">More...</a><br /></td></tr>
<tr class="separator:gaf6d63040fb70ea0eba06b7874af86479"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga523a126795e301f3ebe0c9f889b6252b"><td class="memItemLeft" align="right" valign="top">__STATIC_FORCEINLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga523a126795e301f3ebe0c9f889b6252b">i2c_set_clock_status</a> (<a class="el" href="group___i2_c.html#ga489a90df00c3703b26d667dbe952b34a">i2c_clock_t</a> status)</td></tr>
<tr class="memdesc:ga523a126795e301f3ebe0c9f889b6252b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set I2C clock status.  <a href="#ga523a126795e301f3ebe0c9f889b6252b">More...</a><br /></td></tr>
<tr class="separator:ga523a126795e301f3ebe0c9f889b6252b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3904cc220e126100807a68ceb638f941"><td class="memItemLeft" align="right" valign="top">__STATIC_FORCEINLINE <a class="el" href="group___i2_c.html#ga489a90df00c3703b26d667dbe952b34a">i2c_clock_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga3904cc220e126100807a68ceb638f941">i2c_get_clock_status</a> (void)</td></tr>
<tr class="memdesc:ga3904cc220e126100807a68ceb638f941"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get I2C clock status.  <a href="#ga3904cc220e126100807a68ceb638f941">More...</a><br /></td></tr>
<tr class="separator:ga3904cc220e126100807a68ceb638f941"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf67bc82c706451c1afd5ba8864cabf43"><td class="memItemLeft" align="right" valign="top">__STATIC_FORCEINLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#gaf67bc82c706451c1afd5ba8864cabf43">i2c_set_mode</a> (<a class="el" href="group___i2_c.html#gac1e2996ebee909590af8e3cc1c316c25">i2c_mode_t</a> mode)</td></tr>
<tr class="memdesc:gaf67bc82c706451c1afd5ba8864cabf43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set I2C controller mode.  <a href="#gaf67bc82c706451c1afd5ba8864cabf43">More...</a><br /></td></tr>
<tr class="separator:gaf67bc82c706451c1afd5ba8864cabf43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d3deafadb3c0dae0e938d6033c1bb73"><td class="memItemLeft" align="right" valign="top">__STATIC_FORCEINLINE <a class="el" href="group___i2_c.html#gac1e2996ebee909590af8e3cc1c316c25">i2c_mode_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga9d3deafadb3c0dae0e938d6033c1bb73">i2c_get_mode</a> (void)</td></tr>
<tr class="memdesc:ga9d3deafadb3c0dae0e938d6033c1bb73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get I2C controller mode.  <a href="#ga9d3deafadb3c0dae0e938d6033c1bb73">More...</a><br /></td></tr>
<tr class="separator:ga9d3deafadb3c0dae0e938d6033c1bb73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga595151c3516c042956d9f4f8e05a0c47"><td class="memItemLeft" align="right" valign="top">__STATIC_FORCEINLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga595151c3516c042956d9f4f8e05a0c47">i2c_set_speed</a> (<a class="el" href="group___i2_c.html#ga6e6a870f98abb8cffa95373b69fb8243">i2c_speed_t</a> speed)</td></tr>
<tr class="memdesc:ga595151c3516c042956d9f4f8e05a0c47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set I2C interface bus speed.  <a href="#ga595151c3516c042956d9f4f8e05a0c47">More...</a><br /></td></tr>
<tr class="separator:ga595151c3516c042956d9f4f8e05a0c47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1a8c76488daacb83f528ccb3df320d80"><td class="memItemLeft" align="right" valign="top">__STATIC_FORCEINLINE <a class="el" href="group___i2_c.html#ga6e6a870f98abb8cffa95373b69fb8243">i2c_speed_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga1a8c76488daacb83f528ccb3df320d80">i2c_get_speed</a> (void)</td></tr>
<tr class="memdesc:ga1a8c76488daacb83f528ccb3df320d80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get I2C interface bus speed.  <a href="#ga1a8c76488daacb83f528ccb3df320d80">More...</a><br /></td></tr>
<tr class="separator:ga1a8c76488daacb83f528ccb3df320d80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5bca8b2e12970c2ecd653715494cba1d"><td class="memItemLeft" align="right" valign="top">__STATIC_FORCEINLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga5bca8b2e12970c2ecd653715494cba1d">i2c_set_restart_status</a> (<a class="el" href="group___i2_c.html#gaf7bd376b040c7c04820bdc6abf3a9a7c">i2c_restart_t</a> restart)</td></tr>
<tr class="memdesc:ga5bca8b2e12970c2ecd653715494cba1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set whether RESTART conditions may be sent when acting as master.  <a href="#ga5bca8b2e12970c2ecd653715494cba1d">More...</a><br /></td></tr>
<tr class="separator:ga5bca8b2e12970c2ecd653715494cba1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1a43c4a223d798f3abe9fa6657bb3509"><td class="memItemLeft" align="right" valign="top">__STATIC_FORCEINLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga1a43c4a223d798f3abe9fa6657bb3509">i2c_set_target_addressing_mode</a> (<a class="el" href="group___i2_c.html#ga65b8e8a3eb198a1aa5fac5639a46e8cb">i2c_addressing_t</a> addr_mode)</td></tr>
<tr class="memdesc:ga1a43c4a223d798f3abe9fa6657bb3509"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set target slave addressing mode in master mode.  <a href="#ga1a43c4a223d798f3abe9fa6657bb3509">More...</a><br /></td></tr>
<tr class="separator:ga1a43c4a223d798f3abe9fa6657bb3509"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec7ae6466df5d40cdd8e63b422f1c10c"><td class="memItemLeft" align="right" valign="top">__STATIC_FORCEINLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#gaec7ae6466df5d40cdd8e63b422f1c10c">i2c_set_target_address</a> (uint16_t address)</td></tr>
<tr class="memdesc:gaec7ae6466df5d40cdd8e63b422f1c10c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set target slave address in master mode.  <a href="#gaec7ae6466df5d40cdd8e63b422f1c10c">More...</a><br /></td></tr>
<tr class="separator:gaec7ae6466df5d40cdd8e63b422f1c10c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ce893737b3c1eeeef44c4e1aadb5709"><td class="memItemLeft" align="right" valign="top">__STATIC_FORCEINLINE uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga3ce893737b3c1eeeef44c4e1aadb5709">i2c_get_target_address</a> (void)</td></tr>
<tr class="memdesc:ga3ce893737b3c1eeeef44c4e1aadb5709"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get target address.  <a href="#ga3ce893737b3c1eeeef44c4e1aadb5709">More...</a><br /></td></tr>
<tr class="separator:ga3ce893737b3c1eeeef44c4e1aadb5709"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga98d55f19c685fce01ff63e3565add6ff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga98d55f19c685fce01ff63e3565add6ff">i2c_setup_master</a> (<a class="el" href="group___i2_c.html#gaf7bd376b040c7c04820bdc6abf3a9a7c">i2c_restart_t</a> restart, <a class="el" href="group___i2_c.html#ga65b8e8a3eb198a1aa5fac5639a46e8cb">i2c_addressing_t</a> addr_mode, uint16_t target_addr)</td></tr>
<tr class="memdesc:ga98d55f19c685fce01ff63e3565add6ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setup controller for operation in master mode.  <a href="#ga98d55f19c685fce01ff63e3565add6ff">More...</a><br /></td></tr>
<tr class="separator:ga98d55f19c685fce01ff63e3565add6ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga13d1ece785bf7604734c6e1d0b178fb7"><td class="memItemLeft" align="right" valign="top">__STATIC_FORCEINLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga13d1ece785bf7604734c6e1d0b178fb7">i2c_set_slave_addressing_mode</a> (<a class="el" href="group___i2_c.html#ga65b8e8a3eb198a1aa5fac5639a46e8cb">i2c_addressing_t</a> addr_mode)</td></tr>
<tr class="memdesc:ga13d1ece785bf7604734c6e1d0b178fb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set slave addressing mode in slave mode.  <a href="#ga13d1ece785bf7604734c6e1d0b178fb7">More...</a><br /></td></tr>
<tr class="separator:ga13d1ece785bf7604734c6e1d0b178fb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac230641c51613d45ee0170e3134efd80"><td class="memItemLeft" align="right" valign="top">__STATIC_FORCEINLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#gac230641c51613d45ee0170e3134efd80">i2c_set_slave_address</a> (uint16_t address)</td></tr>
<tr class="memdesc:gac230641c51613d45ee0170e3134efd80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set slave address in slave mode.  <a href="#gac230641c51613d45ee0170e3134efd80">More...</a><br /></td></tr>
<tr class="separator:gac230641c51613d45ee0170e3134efd80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8cec46af7351e65ab3d79a14dd3462f4"><td class="memItemLeft" align="right" valign="top">__STATIC_FORCEINLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga8cec46af7351e65ab3d79a14dd3462f4">i2c_set_general_call_enabled</a> (bool enabled)</td></tr>
<tr class="memdesc:ga8cec46af7351e65ab3d79a14dd3462f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set whether General Call should be used to address slaves.  <a href="#ga8cec46af7351e65ab3d79a14dd3462f4">More...</a><br /></td></tr>
<tr class="separator:ga8cec46af7351e65ab3d79a14dd3462f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga92eb7f6635986a23051435e6af7b814a"><td class="memItemLeft" align="right" valign="top">__STATIC_FORCEINLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga92eb7f6635986a23051435e6af7b814a">i2c_set_general_call_ack_enabled</a> (bool ack)</td></tr>
<tr class="memdesc:ga92eb7f6635986a23051435e6af7b814a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set support for general call acknowledgment.  <a href="#ga92eb7f6635986a23051435e6af7b814a">More...</a><br /></td></tr>
<tr class="separator:ga92eb7f6635986a23051435e6af7b814a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d5b9d902befb2354ef90fd25538be20"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga0d5b9d902befb2354ef90fd25538be20">i2c_setup_slave</a> (<a class="el" href="group___i2_c.html#ga65b8e8a3eb198a1aa5fac5639a46e8cb">i2c_addressing_t</a> addr_mode, uint16_t addr)</td></tr>
<tr class="memdesc:ga0d5b9d902befb2354ef90fd25538be20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setup controller for operation in slave mode.  <a href="#ga0d5b9d902befb2354ef90fd25538be20">More...</a><br /></td></tr>
<tr class="separator:ga0d5b9d902befb2354ef90fd25538be20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2e7098916d199b078b46723872b6bc94"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga2e7098916d199b078b46723872b6bc94">i2c_init</a> (const <a class="el" href="structi2c__cfg__t.html">i2c_cfg_t</a> *cfg)</td></tr>
<tr class="memdesc:ga2e7098916d199b078b46723872b6bc94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize I2C controller.  <a href="#ga2e7098916d199b078b46723872b6bc94">More...</a><br /></td></tr>
<tr class="separator:ga2e7098916d199b078b46723872b6bc94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacaa348818829b078d6033406956040c9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#gacaa348818829b078d6033406956040c9">i2c_release</a> (void)</td></tr>
<tr class="memdesc:gacaa348818829b078d6033406956040c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable I2C controller and clock.  <a href="#gacaa348818829b078d6033406956040c9">More...</a><br /></td></tr>
<tr class="separator:gacaa348818829b078d6033406956040c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada439eb78303e8d9fb8085e6e1b59dcb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#gada439eb78303e8d9fb8085e6e1b59dcb">i2c_register_int</a> (<a class="el" href="group___i2_c.html#ga27e69e4d2343eb297877e1894ff2df34">i2c_interrupt_cb_t</a> cb, uint16_t mask)</td></tr>
<tr class="memdesc:gada439eb78303e8d9fb8085e6e1b59dcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register interrupt handler.  <a href="#gada439eb78303e8d9fb8085e6e1b59dcb">More...</a><br /></td></tr>
<tr class="separator:gada439eb78303e8d9fb8085e6e1b59dcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e0617f68035338884e218a18f778661"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga8e0617f68035338884e218a18f778661">i2c_unregister_int</a> (void)</td></tr>
<tr class="memdesc:ga8e0617f68035338884e218a18f778661"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unregister interrupt handler.  <a href="#ga8e0617f68035338884e218a18f778661">More...</a><br /></td></tr>
<tr class="separator:ga8e0617f68035338884e218a18f778661"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafbfbce6b4b6bbd86cb30426b2fe42102"><td class="memItemLeft" align="right" valign="top">__STATIC_FORCEINLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#gafbfbce6b4b6bbd86cb30426b2fe42102">i2c_set_int_mask</a> (uint16_t mask)</td></tr>
<tr class="memdesc:gafbfbce6b4b6bbd86cb30426b2fe42102"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set I2C interrupt mask.  <a href="#gafbfbce6b4b6bbd86cb30426b2fe42102">More...</a><br /></td></tr>
<tr class="separator:gafbfbce6b4b6bbd86cb30426b2fe42102"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga93fda638161711dbd44da42a73636ccc"><td class="memItemLeft" align="right" valign="top">__STATIC_FORCEINLINE uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga93fda638161711dbd44da42a73636ccc">i2c_get_int_mask</a> (void)</td></tr>
<tr class="memdesc:ga93fda638161711dbd44da42a73636ccc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get I2C interrupt mask.  <a href="#ga93fda638161711dbd44da42a73636ccc">More...</a><br /></td></tr>
<tr class="separator:ga93fda638161711dbd44da42a73636ccc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c8db6f59f5462265d7ea7310ec74b8c"><td class="memItemLeft" align="right" valign="top">__STATIC_FORCEINLINE uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga5c8db6f59f5462265d7ea7310ec74b8c">i2c_get_int_state</a> (void)</td></tr>
<tr class="memdesc:ga5c8db6f59f5462265d7ea7310ec74b8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get interrupt state.  <a href="#ga5c8db6f59f5462265d7ea7310ec74b8c">More...</a><br /></td></tr>
<tr class="separator:ga5c8db6f59f5462265d7ea7310ec74b8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf01891bad008811831e9712bed629eb6"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#gaf01891bad008811831e9712bed629eb6">i2c_get_raw_int_state</a> (void)</td></tr>
<tr class="memdesc:gaf01891bad008811831e9712bed629eb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get raw interrupt state.  <a href="#gaf01891bad008811831e9712bed629eb6">More...</a><br /></td></tr>
<tr class="separator:gaf01891bad008811831e9712bed629eb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaccd7592c4fbb6ac1267805dd55371a66"><td class="memItemLeft" align="right" valign="top">__STATIC_FORCEINLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#gaccd7592c4fbb6ac1267805dd55371a66">i2c_reset_int_all</a> (void)</td></tr>
<tr class="memdesc:gaccd7592c4fbb6ac1267805dd55371a66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset all interrupt state.  <a href="#gaccd7592c4fbb6ac1267805dd55371a66">More...</a><br /></td></tr>
<tr class="separator:gaccd7592c4fbb6ac1267805dd55371a66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga90c34ade55b4489cee09bcd3c4c7b004"><td class="memItemLeft" align="right" valign="top">__STATIC_FORCEINLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga90c34ade55b4489cee09bcd3c4c7b004">i2c_reset_int_rx_underflow</a> (void)</td></tr>
<tr class="memdesc:ga90c34ade55b4489cee09bcd3c4c7b004"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset RX_UNDERFLOW interrupt state.  <a href="#ga90c34ade55b4489cee09bcd3c4c7b004">More...</a><br /></td></tr>
<tr class="separator:ga90c34ade55b4489cee09bcd3c4c7b004"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga03ea6baee64f5c7785868f9e931321f5"><td class="memItemLeft" align="right" valign="top">__STATIC_FORCEINLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga03ea6baee64f5c7785868f9e931321f5">i2c_reset_int_rx_overflow</a> (void)</td></tr>
<tr class="memdesc:ga03ea6baee64f5c7785868f9e931321f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset RX_OVERFLOW interrupt state.  <a href="#ga03ea6baee64f5c7785868f9e931321f5">More...</a><br /></td></tr>
<tr class="separator:ga03ea6baee64f5c7785868f9e931321f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga93f296885fedf36d6fa91669974c0bd9"><td class="memItemLeft" align="right" valign="top">__STATIC_FORCEINLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga93f296885fedf36d6fa91669974c0bd9">i2c_reset_int_tx_overflow</a> (void)</td></tr>
<tr class="memdesc:ga93f296885fedf36d6fa91669974c0bd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset TX_OVERFLOW interrupt state.  <a href="#ga93f296885fedf36d6fa91669974c0bd9">More...</a><br /></td></tr>
<tr class="separator:ga93f296885fedf36d6fa91669974c0bd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaa2e710cd63a6bd777bc7f5469ce7dcb"><td class="memItemLeft" align="right" valign="top">__STATIC_FORCEINLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#gaaa2e710cd63a6bd777bc7f5469ce7dcb">i2c_reset_int_read_request</a> (void)</td></tr>
<tr class="memdesc:gaaa2e710cd63a6bd777bc7f5469ce7dcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset READ_REQUEST interrupt state.  <a href="#gaaa2e710cd63a6bd777bc7f5469ce7dcb">More...</a><br /></td></tr>
<tr class="separator:gaaa2e710cd63a6bd777bc7f5469ce7dcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab3093a20c41758257e74f463159a12bc"><td class="memItemLeft" align="right" valign="top">__STATIC_FORCEINLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#gab3093a20c41758257e74f463159a12bc">i2c_reset_int_tx_abort</a> (void)</td></tr>
<tr class="memdesc:gab3093a20c41758257e74f463159a12bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset TX_ABORT interrupt state.  <a href="#gab3093a20c41758257e74f463159a12bc">More...</a><br /></td></tr>
<tr class="separator:gab3093a20c41758257e74f463159a12bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc298e6b24294e2b2413a707d78c409c"><td class="memItemLeft" align="right" valign="top">__STATIC_FORCEINLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#gadc298e6b24294e2b2413a707d78c409c">i2c_reset_int_rx_done</a> (void)</td></tr>
<tr class="memdesc:gadc298e6b24294e2b2413a707d78c409c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset RX_DONE interrupt state.  <a href="#gadc298e6b24294e2b2413a707d78c409c">More...</a><br /></td></tr>
<tr class="separator:gadc298e6b24294e2b2413a707d78c409c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac4fcfc2bf69cac71bcd42748d37cfe38"><td class="memItemLeft" align="right" valign="top">__STATIC_FORCEINLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#gac4fcfc2bf69cac71bcd42748d37cfe38">i2c_reset_int_activity</a> (void)</td></tr>
<tr class="memdesc:gac4fcfc2bf69cac71bcd42748d37cfe38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset ACTIVITY interrupt state.  <a href="#gac4fcfc2bf69cac71bcd42748d37cfe38">More...</a><br /></td></tr>
<tr class="separator:gac4fcfc2bf69cac71bcd42748d37cfe38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a508adaaf88a5c293f1ba6473f69aee"><td class="memItemLeft" align="right" valign="top">__STATIC_FORCEINLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga4a508adaaf88a5c293f1ba6473f69aee">i2c_reset_int_start_detected</a> (void)</td></tr>
<tr class="memdesc:ga4a508adaaf88a5c293f1ba6473f69aee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset START_DETECTED interrupt state.  <a href="#ga4a508adaaf88a5c293f1ba6473f69aee">More...</a><br /></td></tr>
<tr class="separator:ga4a508adaaf88a5c293f1ba6473f69aee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa55964b5f006b61f862dd412e8aa515b"><td class="memItemLeft" align="right" valign="top">__STATIC_FORCEINLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#gaa55964b5f006b61f862dd412e8aa515b">i2c_reset_int_stop_detected</a> (void)</td></tr>
<tr class="memdesc:gaa55964b5f006b61f862dd412e8aa515b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset STOP_DETECTED interrupt state.  <a href="#gaa55964b5f006b61f862dd412e8aa515b">More...</a><br /></td></tr>
<tr class="separator:gaa55964b5f006b61f862dd412e8aa515b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7523b9932b2f087f21e38be40f41bec7"><td class="memItemLeft" align="right" valign="top">__STATIC_FORCEINLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga7523b9932b2f087f21e38be40f41bec7">i2c_reset_int_gen_call</a> (void)</td></tr>
<tr class="memdesc:ga7523b9932b2f087f21e38be40f41bec7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset GENERAL_CALL interrupt state.  <a href="#ga7523b9932b2f087f21e38be40f41bec7">More...</a><br /></td></tr>
<tr class="separator:ga7523b9932b2f087f21e38be40f41bec7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c77916d6a1270e3a1e2bfcdc51a5c79"><td class="memItemLeft" align="right" valign="top">__STATIC_FORCEINLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga2c77916d6a1270e3a1e2bfcdc51a5c79">i2c_set_tx_fifo_threshold</a> (uint8_t level)</td></tr>
<tr class="memdesc:ga2c77916d6a1270e3a1e2bfcdc51a5c79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set threshold level on TX FIFO.  <a href="#ga2c77916d6a1270e3a1e2bfcdc51a5c79">More...</a><br /></td></tr>
<tr class="separator:ga2c77916d6a1270e3a1e2bfcdc51a5c79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafa3f587bfcd805f5c0caf4a75514262a"><td class="memItemLeft" align="right" valign="top">__STATIC_FORCEINLINE uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#gafa3f587bfcd805f5c0caf4a75514262a">i2c_get_tx_fifo_threshold</a> (void)</td></tr>
<tr class="memdesc:gafa3f587bfcd805f5c0caf4a75514262a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get threshold level on TX FIFO.  <a href="#gafa3f587bfcd805f5c0caf4a75514262a">More...</a><br /></td></tr>
<tr class="separator:gafa3f587bfcd805f5c0caf4a75514262a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9b9ad1c516e33d7e52838b02a60aa0ca"><td class="memItemLeft" align="right" valign="top">__STATIC_FORCEINLINE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga9b9ad1c516e33d7e52838b02a60aa0ca">i2c_is_tx_fifo_empty</a> (void)</td></tr>
<tr class="memdesc:ga9b9ad1c516e33d7e52838b02a60aa0ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if TX FIFO queue is empty.  <a href="#ga9b9ad1c516e33d7e52838b02a60aa0ca">More...</a><br /></td></tr>
<tr class="separator:ga9b9ad1c516e33d7e52838b02a60aa0ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa20592a0108b29bbe5eeed40e5976b34"><td class="memItemLeft" align="right" valign="top">__STATIC_FORCEINLINE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#gaa20592a0108b29bbe5eeed40e5976b34">i2c_is_tx_fifo_not_full</a> (void)</td></tr>
<tr class="memdesc:gaa20592a0108b29bbe5eeed40e5976b34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if TX FIFO is not full.  <a href="#gaa20592a0108b29bbe5eeed40e5976b34">More...</a><br /></td></tr>
<tr class="separator:gaa20592a0108b29bbe5eeed40e5976b34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec9341515b75c133794c6b697bc3cd91"><td class="memItemLeft" align="right" valign="top">__STATIC_FORCEINLINE uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#gaec9341515b75c133794c6b697bc3cd91">i2c_get_tx_fifo_level</a> (void)</td></tr>
<tr class="memdesc:gaec9341515b75c133794c6b697bc3cd91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get number of bytes in TX FIFO.  <a href="#gaec9341515b75c133794c6b697bc3cd91">More...</a><br /></td></tr>
<tr class="separator:gaec9341515b75c133794c6b697bc3cd91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2cbfc9add48d0ce2f18089ff8b4eae14"><td class="memItemLeft" align="right" valign="top">__STATIC_FORCEINLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga2cbfc9add48d0ce2f18089ff8b4eae14">i2c_set_rx_fifo_threshold</a> (uint8_t level)</td></tr>
<tr class="memdesc:ga2cbfc9add48d0ce2f18089ff8b4eae14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set threshold level on RX FIFO.  <a href="#ga2cbfc9add48d0ce2f18089ff8b4eae14">More...</a><br /></td></tr>
<tr class="separator:ga2cbfc9add48d0ce2f18089ff8b4eae14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabca9146557ba29464e1104d004ddbb57"><td class="memItemLeft" align="right" valign="top">__STATIC_FORCEINLINE uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#gabca9146557ba29464e1104d004ddbb57">i2c_get_rx_fifo_threshold</a> (void)</td></tr>
<tr class="memdesc:gabca9146557ba29464e1104d004ddbb57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get threshold level on TX FIFO.  <a href="#gabca9146557ba29464e1104d004ddbb57">More...</a><br /></td></tr>
<tr class="separator:gabca9146557ba29464e1104d004ddbb57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e9a872ee3121e74b27565add4b8bf9c"><td class="memItemLeft" align="right" valign="top">__STATIC_FORCEINLINE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga7e9a872ee3121e74b27565add4b8bf9c">i2c_is_rx_fifo_full</a> (void)</td></tr>
<tr class="memdesc:ga7e9a872ee3121e74b27565add4b8bf9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if RX FIFO queue is full.  <a href="#ga7e9a872ee3121e74b27565add4b8bf9c">More...</a><br /></td></tr>
<tr class="separator:ga7e9a872ee3121e74b27565add4b8bf9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad67653f31491d3ea1e0b5c4ddcb7f2a1"><td class="memItemLeft" align="right" valign="top">__STATIC_FORCEINLINE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#gad67653f31491d3ea1e0b5c4ddcb7f2a1">i2c_is_rx_fifo_not_empty</a> (void)</td></tr>
<tr class="memdesc:gad67653f31491d3ea1e0b5c4ddcb7f2a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if RX FIFO is not empty.  <a href="#gad67653f31491d3ea1e0b5c4ddcb7f2a1">More...</a><br /></td></tr>
<tr class="separator:gad67653f31491d3ea1e0b5c4ddcb7f2a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga041565eaf33cf5a741573958f37836f7"><td class="memItemLeft" align="right" valign="top">__STATIC_FORCEINLINE uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga041565eaf33cf5a741573958f37836f7">i2c_get_rx_fifo_level</a> (void)</td></tr>
<tr class="memdesc:ga041565eaf33cf5a741573958f37836f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get number of bytes in RX FIFO.  <a href="#ga041565eaf33cf5a741573958f37836f7">More...</a><br /></td></tr>
<tr class="separator:ga041565eaf33cf5a741573958f37836f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga19404904f0fe5f700e6ca2f32127b1f2"><td class="memItemLeft" align="right" valign="top">__STATIC_FORCEINLINE <a class="el" href="group___i2_c.html#gaef40399c7569e3b745df70b86b7107bd">i2c_abort_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga19404904f0fe5f700e6ca2f32127b1f2">i2c_get_abort_source</a> (void)</td></tr>
<tr class="memdesc:ga19404904f0fe5f700e6ca2f32127b1f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get abort source.  <a href="#ga19404904f0fe5f700e6ca2f32127b1f2">More...</a><br /></td></tr>
<tr class="separator:ga19404904f0fe5f700e6ca2f32127b1f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga06743d3a41983ab061e6892ba090d9c7"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga06743d3a41983ab061e6892ba090d9c7">i2c_reset_abort_source</a> (void)</td></tr>
<tr class="memdesc:ga06743d3a41983ab061e6892ba090d9c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset abort source.  <a href="#ga06743d3a41983ab061e6892ba090d9c7">More...</a><br /></td></tr>
<tr class="separator:ga06743d3a41983ab061e6892ba090d9c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae30db5d1f0d24a7f772c177963dabf6a"><td class="memItemLeft" align="right" valign="top">__STATIC_FORCEINLINE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#gae30db5d1f0d24a7f772c177963dabf6a">i2c_is_slave_busy</a> (void)</td></tr>
<tr class="memdesc:gae30db5d1f0d24a7f772c177963dabf6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if controller is busy when operating in slave mode.  <a href="#gae30db5d1f0d24a7f772c177963dabf6a">More...</a><br /></td></tr>
<tr class="separator:gae30db5d1f0d24a7f772c177963dabf6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45a444b8a48c98b8213aa9944b44e578"><td class="memItemLeft" align="right" valign="top">__STATIC_FORCEINLINE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga45a444b8a48c98b8213aa9944b44e578">i2c_is_master_busy</a> (void)</td></tr>
<tr class="memdesc:ga45a444b8a48c98b8213aa9944b44e578"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if controller is busy when operating in master mode.  <a href="#ga45a444b8a48c98b8213aa9944b44e578">More...</a><br /></td></tr>
<tr class="separator:ga45a444b8a48c98b8213aa9944b44e578"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaabdab0dda772ef4297e65751d4df452d"><td class="memItemLeft" align="right" valign="top">__STATIC_FORCEINLINE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#gaabdab0dda772ef4297e65751d4df452d">i2c_controler_is_busy</a> (void)</td></tr>
<tr class="memdesc:gaabdab0dda772ef4297e65751d4df452d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check controller activity.  <a href="#gaabdab0dda772ef4297e65751d4df452d">More...</a><br /></td></tr>
<tr class="separator:gaabdab0dda772ef4297e65751d4df452d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaea9ff475e5a350eae2e16f5c7fda14d0"><td class="memItemLeft" align="right" valign="top">__STATIC_FORCEINLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#gaea9ff475e5a350eae2e16f5c7fda14d0">i2c_write_byte</a> (uint16_t data)</td></tr>
<tr class="memdesc:gaea9ff475e5a350eae2e16f5c7fda14d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write single byte into TX FIFO.  <a href="#gaea9ff475e5a350eae2e16f5c7fda14d0">More...</a><br /></td></tr>
<tr class="separator:gaea9ff475e5a350eae2e16f5c7fda14d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafabf674fb0a1f15d761e1cade43a1777"><td class="memItemLeft" align="right" valign="top">__STATIC_FORCEINLINE uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#gafabf674fb0a1f15d761e1cade43a1777">i2c_read_byte</a> (void)</td></tr>
<tr class="memdesc:gafabf674fb0a1f15d761e1cade43a1777"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read single byte from RX FIFO.  <a href="#gafabf674fb0a1f15d761e1cade43a1777">More...</a><br /></td></tr>
<tr class="separator:gafabf674fb0a1f15d761e1cade43a1777"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga701ada9b4f01a66f2ab1f85382c3c1e0"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga701ada9b4f01a66f2ab1f85382c3c1e0">i2c_master_transmit_buffer_sync</a> (const uint8_t *data, uint16_t len, <a class="el" href="group___i2_c.html#gaef40399c7569e3b745df70b86b7107bd">i2c_abort_t</a> *abrt_code, uint32_t flags)</td></tr>
<tr class="memdesc:ga701ada9b4f01a66f2ab1f85382c3c1e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write multiple bytes to I2C slave synchronously.  <a href="#ga701ada9b4f01a66f2ab1f85382c3c1e0">More...</a><br /></td></tr>
<tr class="separator:ga701ada9b4f01a66f2ab1f85382c3c1e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf0a0f5a2dfdfdc4da6f3e1af6acc96e"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#gadf0a0f5a2dfdfdc4da6f3e1af6acc96e">i2c_master_receive_buffer_sync</a> (uint8_t *data, uint16_t len, <a class="el" href="group___i2_c.html#gaef40399c7569e3b745df70b86b7107bd">i2c_abort_t</a> *abrt_code, uint32_t flags)</td></tr>
<tr class="memdesc:gadf0a0f5a2dfdfdc4da6f3e1af6acc96e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read multiple bytes from I2C slave synchronously.  <a href="#gadf0a0f5a2dfdfdc4da6f3e1af6acc96e">More...</a><br /></td></tr>
<tr class="separator:gadf0a0f5a2dfdfdc4da6f3e1af6acc96e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaacfd26c9c34f86eaab274eaa0618a092"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#gaacfd26c9c34f86eaab274eaa0618a092">i2c_master_transmit_buffer_async</a> (const uint8_t *data, uint16_t len, <a class="el" href="group___i2_c.html#ga678dc6024a1d54d4709c78d5e64e9974">i2c_complete_cb_t</a> cb, void *cb_data, uint32_t flags)</td></tr>
<tr class="memdesc:gaacfd26c9c34f86eaab274eaa0618a092"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write multiple bytes to I2C slave asynchronously.  <a href="#gaacfd26c9c34f86eaab274eaa0618a092">More...</a><br /></td></tr>
<tr class="separator:gaacfd26c9c34f86eaab274eaa0618a092"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga90cb472300b5a4df81a737d6f4b006f8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga90cb472300b5a4df81a737d6f4b006f8">i2c_master_receive_buffer_async</a> (uint8_t *data, uint16_t len, <a class="el" href="group___i2_c.html#ga678dc6024a1d54d4709c78d5e64e9974">i2c_complete_cb_t</a> cb, void *cb_data, uint32_t flags)</td></tr>
<tr class="memdesc:ga90cb472300b5a4df81a737d6f4b006f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read multiple bytes from I2C slave asynchronously.  <a href="#ga90cb472300b5a4df81a737d6f4b006f8">More...</a><br /></td></tr>
<tr class="separator:ga90cb472300b5a4df81a737d6f4b006f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga461b4bfce9b764311bf938c6292f326e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga461b4bfce9b764311bf938c6292f326e">i2c_master_transmit_buffer_dma</a> (<a class="el" href="group___i2_c.html#ga3558b2fdf2da82e49c3b523af752b1d9">i2c_dma_channel_pair_t</a> dma_channel_pair, const uint16_t *data, uint16_t len, <a class="el" href="group___i2_c.html#ga678dc6024a1d54d4709c78d5e64e9974">i2c_complete_cb_t</a> cb, void *cb_data, uint32_t flags)</td></tr>
<tr class="memdesc:ga461b4bfce9b764311bf938c6292f326e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transmit multiple bytes on I2C bus using DMA.  <a href="#ga461b4bfce9b764311bf938c6292f326e">More...</a><br /></td></tr>
<tr class="separator:ga461b4bfce9b764311bf938c6292f326e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac678436710507ceafdba4dbe0585da79"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#gac678436710507ceafdba4dbe0585da79">i2c_master_receive_buffer_dma</a> (<a class="el" href="group___i2_c.html#ga3558b2fdf2da82e49c3b523af752b1d9">i2c_dma_channel_pair_t</a> dma_channel_pair, uint8_t *data, uint16_t len, <a class="el" href="group___i2_c.html#ga678dc6024a1d54d4709c78d5e64e9974">i2c_complete_cb_t</a> cb, void *cb_data, uint32_t flags)</td></tr>
<tr class="memdesc:gac678436710507ceafdba4dbe0585da79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receive multiple bytes from I2C bus using DMA.  <a href="#gac678436710507ceafdba4dbe0585da79">More...</a><br /></td></tr>
<tr class="separator:gac678436710507ceafdba4dbe0585da79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f550ab16d303d20984d810b6b60333d"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga5f550ab16d303d20984d810b6b60333d">i2c_slave_receive_buffer_sync</a> (uint8_t *data, uint16_t len)</td></tr>
<tr class="memdesc:ga5f550ab16d303d20984d810b6b60333d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receive multiple bytes from I2C master synchronously.  <a href="#ga5f550ab16d303d20984d810b6b60333d">More...</a><br /></td></tr>
<tr class="separator:ga5f550ab16d303d20984d810b6b60333d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa8200d2174371fd44842469867653aff"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#gaa8200d2174371fd44842469867653aff">i2c_slave_transmit_buffer_sync</a> (const uint8_t *data, uint16_t len, <a class="el" href="group___i2_c.html#gaef40399c7569e3b745df70b86b7107bd">i2c_abort_t</a> *abrt_code)</td></tr>
<tr class="memdesc:gaa8200d2174371fd44842469867653aff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transmit multiple bytes to I2C master synchronously.  <a href="#gaa8200d2174371fd44842469867653aff">More...</a><br /></td></tr>
<tr class="separator:gaa8200d2174371fd44842469867653aff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga36713e5d8a8273d7c40c5541df68285a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga36713e5d8a8273d7c40c5541df68285a">i2c_slave_receive_buffer_async</a> (uint8_t *data, uint16_t len, <a class="el" href="group___i2_c.html#ga678dc6024a1d54d4709c78d5e64e9974">i2c_complete_cb_t</a> cb, void *cb_data)</td></tr>
<tr class="memdesc:ga36713e5d8a8273d7c40c5541df68285a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receive multiple bytes from I2C master asynchronously.  <a href="#ga36713e5d8a8273d7c40c5541df68285a">More...</a><br /></td></tr>
<tr class="separator:ga36713e5d8a8273d7c40c5541df68285a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6424c4c37d7cb58a42342772e573d3ae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga6424c4c37d7cb58a42342772e573d3ae">i2c_slave_transmit_buffer_async</a> (const uint8_t *data, uint16_t len, <a class="el" href="group___i2_c.html#ga678dc6024a1d54d4709c78d5e64e9974">i2c_complete_cb_t</a> cb, void *cb_data)</td></tr>
<tr class="memdesc:ga6424c4c37d7cb58a42342772e573d3ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transmit multiple bytes to I2C master asynchronously.  <a href="#ga6424c4c37d7cb58a42342772e573d3ae">More...</a><br /></td></tr>
<tr class="separator:ga6424c4c37d7cb58a42342772e573d3ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c8c21c0b5059c361bb3ae58748a29be"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga2c8c21c0b5059c361bb3ae58748a29be">i2c_slave_transmit_buffer_dma</a> (<a class="el" href="group___i2_c.html#ga3558b2fdf2da82e49c3b523af752b1d9">i2c_dma_channel_pair_t</a> dma_channel_pair, const uint16_t *data, uint16_t len, <a class="el" href="group___i2_c.html#ga678dc6024a1d54d4709c78d5e64e9974">i2c_complete_cb_t</a> cb, void *cb_data)</td></tr>
<tr class="memdesc:ga2c8c21c0b5059c361bb3ae58748a29be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transmit multiple bytes on I2C bus using DMA.  <a href="#ga2c8c21c0b5059c361bb3ae58748a29be">More...</a><br /></td></tr>
<tr class="separator:ga2c8c21c0b5059c361bb3ae58748a29be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb52af07e5c9a926fb598b9bfd521004"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#gabb52af07e5c9a926fb598b9bfd521004">i2c_slave_receive_buffer_dma</a> (<a class="el" href="group___i2_c.html#ga3558b2fdf2da82e49c3b523af752b1d9">i2c_dma_channel_pair_t</a> dma_channel_pair, uint8_t *data, uint16_t len, <a class="el" href="group___i2_c.html#ga678dc6024a1d54d4709c78d5e64e9974">i2c_complete_cb_t</a> cb, void *cb_data)</td></tr>
<tr class="memdesc:gabb52af07e5c9a926fb598b9bfd521004"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receive multiple bytes from I2C bus using DMA.  <a href="#gabb52af07e5c9a926fb598b9bfd521004">More...</a><br /></td></tr>
<tr class="separator:gabb52af07e5c9a926fb598b9bfd521004"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga115bca9770b39d69522b5e8c8a62accf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga115bca9770b39d69522b5e8c8a62accf">i2c_prepare_dma</a> (<a class="el" href="group___i2_c.html#ga3558b2fdf2da82e49c3b523af752b1d9">i2c_dma_channel_pair_t</a> dma_channel_pair, void *data, uint16_t len, <a class="el" href="group___i2_c.html#gac688b2325cca3cdc2d76e35fb7199889">i2c_dma_transfer_t</a> type, <a class="el" href="group___i2_c.html#ga678dc6024a1d54d4709c78d5e64e9974">i2c_complete_cb_t</a> cb, void *cb_data, uint32_t flags)</td></tr>
<tr class="memdesc:ga115bca9770b39d69522b5e8c8a62accf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepares I2C DMA for transfer.  <a href="#ga115bca9770b39d69522b5e8c8a62accf">More...</a><br /></td></tr>
<tr class="separator:ga115bca9770b39d69522b5e8c8a62accf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c6a338bfdf17e2c6b0f21746976b74e"><td class="memItemLeft" align="right" valign="top">__STATIC_FORCEINLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga6c6a338bfdf17e2c6b0f21746976b74e">i2c_dma_start</a> (void)</td></tr>
<tr class="memdesc:ga6c6a338bfdf17e2c6b0f21746976b74e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts DMA transfer.  <a href="#ga6c6a338bfdf17e2c6b0f21746976b74e">More...</a><br /></td></tr>
<tr class="separator:ga6c6a338bfdf17e2c6b0f21746976b74e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e7203f1c71397b865ab70b720ba5ad5"><td class="memItemLeft" align="right" valign="top">__STATIC_FORCEINLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga7e7203f1c71397b865ab70b720ba5ad5">i2c_dma_stop</a> (void)</td></tr>
<tr class="memdesc:ga7e7203f1c71397b865ab70b720ba5ad5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stop DMA transfer.  <a href="#ga7e7203f1c71397b865ab70b720ba5ad5">More...</a><br /></td></tr>
<tr class="separator:ga7e7203f1c71397b865ab70b720ba5ad5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae670654b194ef8bbd47beb1f1459710"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#gaae670654b194ef8bbd47beb1f1459710">I2C_Handler</a> (void)</td></tr>
<tr class="memdesc:gaae670654b194ef8bbd47beb1f1459710"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C interrupt handler.  <a href="#gaae670654b194ef8bbd47beb1f1459710">More...</a><br /></td></tr>
<tr class="separator:gaae670654b194ef8bbd47beb1f1459710"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>I2C driver API. </p>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga678dc6024a1d54d4709c78d5e64e9974"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga678dc6024a1d54d4709c78d5e64e9974">&#9670;&nbsp;</a></span>i2c_complete_cb_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* i2c_complete_cb_t) (void *cb_data, uint16_t len, bool success)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback called upon completion of read or write in non-blocking mode (FIFO or DMA) </p>

</div>
</div>
<a id="ga27e69e4d2343eb297877e1894ff2df34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga27e69e4d2343eb297877e1894ff2df34">&#9670;&nbsp;</a></span>i2c_interrupt_cb_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* i2c_interrupt_cb_t) (uint16_t mask)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback called on interrupt from I2C controller. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ga61dadd085c1777f559549e05962b2c9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga61dadd085c1777f559549e05962b2c9e">&#9670;&nbsp;</a></span>anonymous enum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flags passed to master transmit/receive operations. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga61dadd085c1777f559549e05962b2c9ea73a0b58cd5b685a9a417c09cc4dd1129"></a>I2C_F_NONE&#160;</td><td class="fielddoc"><p>No special command for the operation. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga61dadd085c1777f559549e05962b2c9eadfe3b147312a9af12b252fe79e0920ae"></a>I2C_F_WAIT_FOR_STOP&#160;</td><td class="fielddoc"><p>Operation will wait until stop condition occurs. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga61dadd085c1777f559549e05962b2c9eab37107388b51bbb77fab6bf7e88bcc2e"></a>I2C_F_ADD_STOP&#160;</td><td class="fielddoc"><p>Add stop condition after read or write. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga726ca809ffd3d67ab4b8476646f26635"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga726ca809ffd3d67ab4b8476646f26635">&#9670;&nbsp;</a></span>anonymous enum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>I2C interrupt source. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga726ca809ffd3d67ab4b8476646f26635ae8ff2a4b8c47cb9bfc8f5ab2aa62f957"></a>I2C_INT_RX_UNDERFLOW&#160;</td><td class="fielddoc"><p>Attempt to read from empty RX FIFO has been made. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga726ca809ffd3d67ab4b8476646f26635a4c6a06d2d534f85bc39dfefb11efc163"></a>I2C_INT_RX_OVERFLOW&#160;</td><td class="fielddoc"><p>RX FIFO is full but new data are incoming and being discarded. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga726ca809ffd3d67ab4b8476646f26635a9c7016b3a3b0b8a6089a974618adc449"></a>I2C_INT_RX_FULL&#160;</td><td class="fielddoc"><p>RX FIFO level is equal or above threshold. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga726ca809ffd3d67ab4b8476646f26635ae2cf5e4a5847d8c51153500a068e5fc2"></a>I2C_INT_TX_OVERFLOW&#160;</td><td class="fielddoc"><p>Attempt to write to TX FIFO which is already full. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga726ca809ffd3d67ab4b8476646f26635a3e8e02efc2dbd9de0c9c4b57b40edf80"></a>I2C_INT_TX_EMPTY&#160;</td><td class="fielddoc"><p>TX FIFO level is equal or below threshold. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga726ca809ffd3d67ab4b8476646f26635a6f0e95fec2151ef498542bf09672d45c"></a>I2C_INT_READ_REQUEST&#160;</td><td class="fielddoc"><p>I2C master attempts to read data (slave only). </p>
</td></tr>
<tr><td class="fieldname"><a id="gga726ca809ffd3d67ab4b8476646f26635aefd37bcbaa954703bc69cd3ea10bb4db"></a>I2C_INT_TX_ABORT&#160;</td><td class="fielddoc"><p>TX cannot be completed. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga726ca809ffd3d67ab4b8476646f26635a2d90404de3a89aae73e39f7ab8f39ad8"></a>I2C_INT_RX_DONE&#160;</td><td class="fielddoc"><p>I2C master did not acknowledge transmitted byte (slave only). </p>
</td></tr>
<tr><td class="fieldname"><a id="gga726ca809ffd3d67ab4b8476646f26635a85a490f4c65aef9551d36f5abfd6c9ef"></a>I2C_INT_ACTIVITY&#160;</td><td class="fielddoc"><p>Any I2C activity occurred. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga726ca809ffd3d67ab4b8476646f26635aca35bbac8194007368628b12c040cdc1"></a>I2C_INT_STOP_DETECTED&#160;</td><td class="fielddoc"><p>STOP condition occurred. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga726ca809ffd3d67ab4b8476646f26635a18caa4e81a85eef565289d1127b90776"></a>I2C_INT_START_DETECTED&#160;</td><td class="fielddoc"><p>START/RESTART condition occurred. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga726ca809ffd3d67ab4b8476646f26635a148ad5d86616cd5032fa2aba45e57864"></a>I2C_INT_GENERAL_CALL&#160;</td><td class="fielddoc"><p>General Call address received (slave only). </p>
</td></tr>
</table>

</div>
</div>
<a id="gaef40399c7569e3b745df70b86b7107bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaef40399c7569e3b745df70b86b7107bd">&#9670;&nbsp;</a></span>i2c_abort_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___i2_c.html#gaef40399c7569e3b745df70b86b7107bd">i2c_abort_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>I2C abort source. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggaef40399c7569e3b745df70b86b7107bda918faa024ec89a730f50dd2d3c3f8b7d"></a>I2C_ABORT_NONE&#160;</td><td class="fielddoc"><p>No abort occurred. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaef40399c7569e3b745df70b86b7107bdaddd3936bf507790fa4762300d6a263f2"></a>I2C_ABORT_7B_ADDR_NO_ACK&#160;</td><td class="fielddoc"><p>Address byte of 7-bit address was not acknowledged by any slave. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaef40399c7569e3b745df70b86b7107bdaad054085f5e053f52cebaa67364a8143"></a>I2C_ABORT_10B_ADDR1_NO_ACK&#160;</td><td class="fielddoc"><p>1st address byte of the 10-bit address was not acknowledged by any slave. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaef40399c7569e3b745df70b86b7107bda48d3156e99d2a8f95a9f1d570d068351"></a>I2C_ABORT_10B_ADDR2_NO_ACK&#160;</td><td class="fielddoc"><p>2nd address byte of the 10-bit address was not acknowledged by any slave. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaef40399c7569e3b745df70b86b7107bdaa39b1d93218d6140ab9a9cfdd6a86dbe"></a>I2C_ABORT_TX_DATA_NO_ACK&#160;</td><td class="fielddoc"><p>Data were not acknowledged by slave(master mode). </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaef40399c7569e3b745df70b86b7107bdabd3e3eb13d624dd07a0c8c7ab224c39d"></a>I2C_ABORT_GENERAL_CALL_NO_ACK&#160;</td><td class="fielddoc"><p>General Call sent but no slave acknowledged(master mode). </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaef40399c7569e3b745df70b86b7107bdafe704623b449c9ac4db6f341ba41219d"></a>I2C_ABORT_GENERAL_CALL_READ&#160;</td><td class="fielddoc"><p>Trying to read from bus after General Call(master mode). </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaef40399c7569e3b745df70b86b7107bdab01c8a03a9c87ba81cf8ae98b5a205f8"></a>I2C_ABORT_HS_ACKDET&#160;</td><td class="fielddoc"><p>Master is in High Speed mode and the High Speed Master code was acknowledged (wrong behavior). </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaef40399c7569e3b745df70b86b7107bda62fa128de5b4cdf4d7eb9905c6d9f9a3"></a>I2C_ABORT_SBYTE_ACKDET&#160;</td><td class="fielddoc"><p>Master has sent a START Byte and the START Byte was acknowledged (wrong behavior). </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaef40399c7569e3b745df70b86b7107bda8229858e498b5b9bd4132da5e4cea7ab"></a>I2C_ABORT_HS_NORSTRT&#160;</td><td class="fielddoc"><p>High Speed mode with restart disabled. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaef40399c7569e3b745df70b86b7107bdaf585b3c70137a7145e48ef50c803fa46"></a>I2C_ABORT_10B_READ_NO_RESTART&#160;</td><td class="fielddoc"><p>Read command in 10-bit addressing mode with RESTART disabled. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaef40399c7569e3b745df70b86b7107bdae3495840f1c33d692e915fcb5515fd86"></a>I2C_ABORT_MASTER_DISABLED&#160;</td><td class="fielddoc"><p>Master operation initiated with master mode disabled. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaef40399c7569e3b745df70b86b7107bda499bbdfa83de4b93c233413a0178790e"></a>I2C_ABORT_ARBITRATION_LOST&#160;</td><td class="fielddoc"><p>Bus arbitration lost. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaef40399c7569e3b745df70b86b7107bda8e3523cb2ea809e22a3d6234a671c322"></a>I2C_ABORT_SLAVE_FLUSH_TX_FIFO&#160;</td><td class="fielddoc"><p>Request for data with data already in TX FIFO - used to flush data in TX FIFO(slave mode). </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaef40399c7569e3b745df70b86b7107bdaab9c090bfb4ae689730648730a6f3ebf"></a>I2C_ABORT_SLAVE_ARBITRATION_LOST&#160;</td><td class="fielddoc"><p>Bus lost when transmitting to master(slave mode). </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaef40399c7569e3b745df70b86b7107bda268f2f7e41168b00e67eebee05eba701"></a>I2C_ABORT_SLAVE_IN_TX&#160;</td><td class="fielddoc"><p>Request for data replied with read request(slave mode). </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaef40399c7569e3b745df70b86b7107bdad1ca116e4f0db0a96f5b55753db57b11"></a>I2C_ABORT_SW_ERROR&#160;</td><td class="fielddoc"><p>Abort due to software error. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga65b8e8a3eb198a1aa5fac5639a46e8cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga65b8e8a3eb198a1aa5fac5639a46e8cb">&#9670;&nbsp;</a></span>i2c_addressing_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___i2_c.html#ga65b8e8a3eb198a1aa5fac5639a46e8cb">i2c_addressing_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>I2C addressing mode. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga65b8e8a3eb198a1aa5fac5639a46e8cba331406fb33a11a88f96e3ad651bcdb94"></a>I2C_ADDRESSING_7B&#160;</td><td class="fielddoc"><p>7-bit addressing </p>
</td></tr>
<tr><td class="fieldname"><a id="gga65b8e8a3eb198a1aa5fac5639a46e8cba40ae4354c30d2f71caf008b7f40ecb4a"></a>I2C_ADDRESSING_10B&#160;</td><td class="fielddoc"><p>10-bit addressing </p>
</td></tr>
</table>

</div>
</div>
<a id="ga489a90df00c3703b26d667dbe952b34a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga489a90df00c3703b26d667dbe952b34a">&#9670;&nbsp;</a></span>i2c_clock_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___i2_c.html#ga489a90df00c3703b26d667dbe952b34a">i2c_clock_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>I2C clock status. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga489a90df00c3703b26d667dbe952b34aa8e75b80c278d06a0e01bcb8299cb08a2"></a>I2C_CLOCK_DISABLE&#160;</td><td class="fielddoc"><p>I2C clock disable. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga489a90df00c3703b26d667dbe952b34aa1b6aa61a115f3461981fd9e6e3d105ea"></a>I2C_CLOCK_ENABLE&#160;</td><td class="fielddoc"><p>I2C controller enable. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga5bdf6025825018e3fb3ed40081433879"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5bdf6025825018e3fb3ed40081433879">&#9670;&nbsp;</a></span>i2c_controller_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___i2_c.html#ga5bdf6025825018e3fb3ed40081433879">i2c_controller_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>I2C controller status. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga5bdf6025825018e3fb3ed40081433879a036b0230672b1f4d8de2d2c7ec0c3f97"></a>I2C_CONTROLLER_DISABLE&#160;</td><td class="fielddoc"><p>I2C controller disable. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga5bdf6025825018e3fb3ed40081433879a09a8d4a24957d65cb2acbccc69ae1da5"></a>I2C_CONTROLLER_ENABLE&#160;</td><td class="fielddoc"><p>I2C controller enable. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga3558b2fdf2da82e49c3b523af752b1d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3558b2fdf2da82e49c3b523af752b1d9">&#9670;&nbsp;</a></span>i2c_dma_channel_pair_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___i2_c.html#ga3558b2fdf2da82e49c3b523af752b1d9">i2c_dma_channel_pair_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>DMA channel-pairs for I2C. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga3558b2fdf2da82e49c3b523af752b1d9abba262f3627849fba09fbafba96a8ad4"></a>I2C_DMA_CHANNEL_PAIR_1&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga3558b2fdf2da82e49c3b523af752b1d9af40f23877f9c37b1ec5f01e703fa07ad"></a>I2C_DMA_CHANNEL_PAIR_2&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="gac688b2325cca3cdc2d76e35fb7199889"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac688b2325cca3cdc2d76e35fb7199889">&#9670;&nbsp;</a></span>i2c_dma_transfer_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___i2_c.html#gac688b2325cca3cdc2d76e35fb7199889">i2c_dma_transfer_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>DMA transfer type. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggac688b2325cca3cdc2d76e35fb7199889a2d32eea9b8ab106762939e0bb65f6396"></a>I2C_DMA_TRANSFER_WRITE&#160;</td><td class="fielddoc"><p>Master or Slave write transfer. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac688b2325cca3cdc2d76e35fb7199889a538c140bfa79d77185478a9e97732879"></a>I2C_DMA_TRANSFER_MASTER_READ&#160;</td><td class="fielddoc"><p>Master read transfer. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac688b2325cca3cdc2d76e35fb7199889ab7fbf23e7ef39b1ae42b757a8b424cd1"></a>I2C_DMA_TRANSFER_SLAVE_READ&#160;</td><td class="fielddoc"><p>Slave read transfer. </p>
</td></tr>
</table>

</div>
</div>
<a id="gac1e2996ebee909590af8e3cc1c316c25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac1e2996ebee909590af8e3cc1c316c25">&#9670;&nbsp;</a></span>i2c_mode_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___i2_c.html#gac1e2996ebee909590af8e3cc1c316c25">i2c_mode_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>I2C role. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggac1e2996ebee909590af8e3cc1c316c25a10a3fafafb52ab45984aa5d5a17171a0"></a>I2C_MODE_SLAVE&#160;</td><td class="fielddoc"><p>Slave role. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac1e2996ebee909590af8e3cc1c316c25a166443f9a57684d8e4970f28a7acf982"></a>I2C_MODE_MASTER&#160;</td><td class="fielddoc"><p>Master role. </p>
</td></tr>
</table>

</div>
</div>
<a id="gaf7bd376b040c7c04820bdc6abf3a9a7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf7bd376b040c7c04820bdc6abf3a9a7c">&#9670;&nbsp;</a></span>i2c_restart_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___i2_c.html#gaf7bd376b040c7c04820bdc6abf3a9a7c">i2c_restart_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Restart condition. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggaf7bd376b040c7c04820bdc6abf3a9a7cacfa27355e82bc9eabf540a36a80a61a1"></a>I2C_RESTART_DISABLE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ggaf7bd376b040c7c04820bdc6abf3a9a7cafcc6472d4ef868efbe6ad0096e8c8f5c"></a>I2C_RESTART_ENABLE&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="ga6e6a870f98abb8cffa95373b69fb8243"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6e6a870f98abb8cffa95373b69fb8243">&#9670;&nbsp;</a></span>i2c_speed_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___i2_c.html#ga6e6a870f98abb8cffa95373b69fb8243">i2c_speed_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>I2C interface speed. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga6e6a870f98abb8cffa95373b69fb8243a5fdea09fb218ae643bca0188d49f11b4"></a>I2C_SPEED_STANDARD&#160;</td><td class="fielddoc"><p>100 kb/s </p>
</td></tr>
<tr><td class="fieldname"><a id="gga6e6a870f98abb8cffa95373b69fb8243a8dc6cae939d20d56a78d123365caa4ca"></a>I2C_SPEED_FAST&#160;</td><td class="fielddoc"><p>400 kb/s </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gaabdab0dda772ef4297e65751d4df452d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaabdab0dda772ef4297e65751d4df452d">&#9670;&nbsp;</a></span>i2c_controler_is_busy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_FORCEINLINE bool i2c_controler_is_busy </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check controller activity. </p>
<dl class="section return"><dt>Returns</dt><dd>busy status </dd></dl>

</div>
</div>
<a id="ga6c6a338bfdf17e2c6b0f21746976b74e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6c6a338bfdf17e2c6b0f21746976b74e">&#9670;&nbsp;</a></span>i2c_dma_start()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_FORCEINLINE void i2c_dma_start </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Starts DMA transfer. </p>
<p>Should be called once I2C DMA is setup using <a class="el" href="group___i2_c.html#ga115bca9770b39d69522b5e8c8a62accf" title="Prepares I2C DMA for transfer. ">i2c_prepare_dma()</a>. Once started, DMA transfer will only finish once previously specified number of bytes is read or written. </p>

</div>
</div>
<a id="ga7e7203f1c71397b865ab70b720ba5ad5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7e7203f1c71397b865ab70b720ba5ad5">&#9670;&nbsp;</a></span>i2c_dma_stop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_FORCEINLINE void i2c_dma_stop </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stop DMA transfer. </p>

</div>
</div>
<a id="ga19404904f0fe5f700e6ca2f32127b1f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga19404904f0fe5f700e6ca2f32127b1f2">&#9670;&nbsp;</a></span>i2c_get_abort_source()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_FORCEINLINE <a class="el" href="group___i2_c.html#gaef40399c7569e3b745df70b86b7107bd">i2c_abort_t</a> i2c_get_abort_source </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get abort source. </p>
<p>This can be used to retrieve source of TX_ABORT interrupt. TX FIFO is flushed and remains in this state until cleared using <a class="el" href="group___i2_c.html#gab3093a20c41758257e74f463159a12bc" title="Reset TX_ABORT interrupt state. ">i2c_reset_int_tx_abort()</a>. </p><dl class="section return"><dt>Returns</dt><dd>abort source bitmask</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___i2_c.html#ga06743d3a41983ab061e6892ba090d9c7" title="Reset abort source. ">i2c_reset_abort_source</a> </dd></dl>

</div>
</div>
<a id="ga3904cc220e126100807a68ceb638f941"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3904cc220e126100807a68ceb638f941">&#9670;&nbsp;</a></span>i2c_get_clock_status()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_FORCEINLINE <a class="el" href="group___i2_c.html#ga489a90df00c3703b26d667dbe952b34a">i2c_clock_t</a> i2c_get_clock_status </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get I2C clock status. </p>
<dl class="section return"><dt>Returns</dt><dd>clock status </dd></dl>

</div>
</div>
<a id="gaf6d63040fb70ea0eba06b7874af86479"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf6d63040fb70ea0eba06b7874af86479">&#9670;&nbsp;</a></span>i2c_get_controller_status()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_FORCEINLINE <a class="el" href="group___i2_c.html#ga5bdf6025825018e3fb3ed40081433879">i2c_controller_t</a> i2c_get_controller_status </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get I2C Controller Enable status. </p>
<dl class="section return"><dt>Returns</dt><dd>The contents of the I2C Controller enable status </dd></dl>

</div>
</div>
<a id="ga93fda638161711dbd44da42a73636ccc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga93fda638161711dbd44da42a73636ccc">&#9670;&nbsp;</a></span>i2c_get_int_mask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_FORCEINLINE uint16_t i2c_get_int_mask </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get I2C interrupt mask. </p>
<dl class="section return"><dt>Returns</dt><dd>current bitmask </dd></dl>

</div>
</div>
<a id="ga5c8db6f59f5462265d7ea7310ec74b8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5c8db6f59f5462265d7ea7310ec74b8c">&#9670;&nbsp;</a></span>i2c_get_int_state()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_FORCEINLINE uint16_t i2c_get_int_state </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get interrupt state. </p>
<p>Interrupt state returned includes only interrupts which are not masked. For raw interrupt status use <a class="el" href="group___i2_c.html#gaf01891bad008811831e9712bed629eb6" title="Get raw interrupt state. ">i2c_get_raw_int_state()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>current interrupt state bitmask </dd></dl>

</div>
</div>
<a id="ga9d3deafadb3c0dae0e938d6033c1bb73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9d3deafadb3c0dae0e938d6033c1bb73">&#9670;&nbsp;</a></span>i2c_get_mode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_FORCEINLINE <a class="el" href="group___i2_c.html#gac1e2996ebee909590af8e3cc1c316c25">i2c_mode_t</a> i2c_get_mode </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get I2C controller mode. </p>
<dl class="section return"><dt>Returns</dt><dd>Mode of I2C controller </dd></dl>

</div>
</div>
<a id="gaf01891bad008811831e9712bed629eb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf01891bad008811831e9712bed629eb6">&#9670;&nbsp;</a></span>i2c_get_raw_int_state()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint16_t i2c_get_raw_int_state </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get raw interrupt state. </p>
<dl class="section return"><dt>Returns</dt><dd>current interrupt state bitmask </dd></dl>

</div>
</div>
<a id="ga041565eaf33cf5a741573958f37836f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga041565eaf33cf5a741573958f37836f7">&#9670;&nbsp;</a></span>i2c_get_rx_fifo_level()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_FORCEINLINE uint16_t i2c_get_rx_fifo_level </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get number of bytes in RX FIFO. </p>
<dl class="section return"><dt>Returns</dt><dd>number of bytes </dd></dl>

</div>
</div>
<a id="gabca9146557ba29464e1104d004ddbb57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabca9146557ba29464e1104d004ddbb57">&#9670;&nbsp;</a></span>i2c_get_rx_fifo_threshold()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_FORCEINLINE uint16_t i2c_get_rx_fifo_threshold </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get threshold level on TX FIFO. </p>
<dl class="section return"><dt>Returns</dt><dd>RX FIFO threshold </dd></dl>

</div>
</div>
<a id="ga1a8c76488daacb83f528ccb3df320d80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1a8c76488daacb83f528ccb3df320d80">&#9670;&nbsp;</a></span>i2c_get_speed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_FORCEINLINE <a class="el" href="group___i2_c.html#ga6e6a870f98abb8cffa95373b69fb8243">i2c_speed_t</a> i2c_get_speed </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get I2C interface bus speed. </p>
<dl class="section return"><dt>Returns</dt><dd>I2C bus speed </dd></dl>

</div>
</div>
<a id="ga3ce893737b3c1eeeef44c4e1aadb5709"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3ce893737b3c1eeeef44c4e1aadb5709">&#9670;&nbsp;</a></span>i2c_get_target_address()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_FORCEINLINE uint16_t i2c_get_target_address </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get target address. </p>
<dl class="section return"><dt>Returns</dt><dd>target address </dd></dl>

</div>
</div>
<a id="gaec9341515b75c133794c6b697bc3cd91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaec9341515b75c133794c6b697bc3cd91">&#9670;&nbsp;</a></span>i2c_get_tx_fifo_level()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_FORCEINLINE uint16_t i2c_get_tx_fifo_level </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get number of bytes in TX FIFO. </p>
<dl class="section return"><dt>Returns</dt><dd>number of bytes </dd></dl>

</div>
</div>
<a id="gafa3f587bfcd805f5c0caf4a75514262a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafa3f587bfcd805f5c0caf4a75514262a">&#9670;&nbsp;</a></span>i2c_get_tx_fifo_threshold()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_FORCEINLINE uint16_t i2c_get_tx_fifo_threshold </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get threshold level on TX FIFO. </p>
<dl class="section return"><dt>Returns</dt><dd>TX FIFO threshold </dd></dl>

</div>
</div>
<a id="gaae670654b194ef8bbd47beb1f1459710"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaae670654b194ef8bbd47beb1f1459710">&#9670;&nbsp;</a></span>I2C_Handler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2C_Handler </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>I2C interrupt handler. </p>

</div>
</div>
<a id="ga2e7098916d199b078b46723872b6bc94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2e7098916d199b078b46723872b6bc94">&#9670;&nbsp;</a></span>i2c_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void i2c_init </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structi2c__cfg__t.html">i2c_cfg_t</a> *&#160;</td>
          <td class="paramname"><em>cfg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize I2C controller. </p>
<p>I2C controller is disabled, clock and interrupt for I2C component are enabled, all interrupts are masked though. </p><dl class="section note"><dt>Note</dt><dd>In the case of DA14585/DA14586, the PD_PER domain shall be functional prior to I2C initialization: SetBits16(PMU_CTRL_REG, PERIPH_SLEEP, 0); while (!(GetWord16(SYS_STAT_REG) &amp; PER_IS_UP)); </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cfg</td><td>configuration </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga45a444b8a48c98b8213aa9944b44e578"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga45a444b8a48c98b8213aa9944b44e578">&#9670;&nbsp;</a></span>i2c_is_master_busy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_FORCEINLINE bool i2c_is_master_busy </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if controller is busy when operating in master mode. </p>
<dl class="section return"><dt>Returns</dt><dd>busy status </dd></dl>

</div>
</div>
<a id="ga7e9a872ee3121e74b27565add4b8bf9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7e9a872ee3121e74b27565add4b8bf9c">&#9670;&nbsp;</a></span>i2c_is_rx_fifo_full()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_FORCEINLINE bool i2c_is_rx_fifo_full </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if RX FIFO queue is full. </p>
<p>This function should be used to check if RX FIFO is filled, i.e. subsequent data read will be discarded. </p><dl class="section return"><dt>Returns</dt><dd>RX FIFO full status </dd></dl>

</div>
</div>
<a id="gad67653f31491d3ea1e0b5c4ddcb7f2a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad67653f31491d3ea1e0b5c4ddcb7f2a1">&#9670;&nbsp;</a></span>i2c_is_rx_fifo_not_empty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_FORCEINLINE bool i2c_is_rx_fifo_not_empty </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if RX FIFO is not empty. </p>
<p>This function should be used to check if there are any data received in RX FIFO. </p><dl class="section return"><dt>Returns</dt><dd>RX FIFO not empty status </dd></dl>

</div>
</div>
<a id="gae30db5d1f0d24a7f772c177963dabf6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae30db5d1f0d24a7f772c177963dabf6a">&#9670;&nbsp;</a></span>i2c_is_slave_busy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_FORCEINLINE bool i2c_is_slave_busy </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if controller is busy when operating in slave mode. </p>
<dl class="section return"><dt>Returns</dt><dd>busy status </dd></dl>

</div>
</div>
<a id="ga9b9ad1c516e33d7e52838b02a60aa0ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9b9ad1c516e33d7e52838b02a60aa0ca">&#9670;&nbsp;</a></span>i2c_is_tx_fifo_empty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_FORCEINLINE bool i2c_is_tx_fifo_empty </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if TX FIFO queue is empty. </p>
<p>This function should be used to check if all data written to TX FIFO were transmitted. </p><dl class="section return"><dt>Returns</dt><dd>TX FIFO empty status </dd></dl>

</div>
</div>
<a id="gaa20592a0108b29bbe5eeed40e5976b34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa20592a0108b29bbe5eeed40e5976b34">&#9670;&nbsp;</a></span>i2c_is_tx_fifo_not_full()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_FORCEINLINE bool i2c_is_tx_fifo_not_full </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if TX FIFO is not full. </p>
<p>This function should be used to check if data can be written to TX FIFO. </p><dl class="section return"><dt>Returns</dt><dd>TX FIFO not full status </dd></dl>

</div>
</div>
<a id="ga90cb472300b5a4df81a737d6f4b006f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga90cb472300b5a4df81a737d6f4b006f8">&#9670;&nbsp;</a></span>i2c_master_receive_buffer_async()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void i2c_master_receive_buffer_async </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___i2_c.html#ga678dc6024a1d54d4709c78d5e64e9974">i2c_complete_cb_t</a>&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read multiple bytes from I2C slave asynchronously. </p>
<p>This function will read multiple bytes from bus taking care of RX FIFO control. This call is non-blocking and specified callback is called upon completion, with the operation status. The operation completes when the complete buffer is filled, or in case of a failure. In case of failure the failure cause must be read from the cb by calling <a class="el" href="group___i2_c.html#ga19404904f0fe5f700e6ca2f32127b1f2" title="Get abort source. ">i2c_get_abort_source()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">data</td><td>Address of the buffer where data are stored </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Length of the data buffer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb</td><td>Callback to be called upon completion </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb_data</td><td>Data to pass to cb </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>Possible values for flags are: <p class="starttd"><a class="el" href="group___i2_c.html#gga61dadd085c1777f559549e05962b2c9ea73a0b58cd5b685a9a417c09cc4dd1129" title="No special command for the operation. ">I2C_F_NONE</a><br />
 This flag can be used for consecutive calls where the transaction can resume without stop/start conditions in between. In case of DA14585 STOP condition is automatically generated at the end of the transaction.</p>
<p class="endtd"><a class="el" href="group___i2_c.html#gga61dadd085c1777f559549e05962b2c9eab37107388b51bbb77fab6bf7e88bcc2e" title="Add stop condition after read or write. ">I2C_F_ADD_STOP</a><br />
 STOP condition will be generated at the end of the transaction. This flag has no effect in DA14585/6 since STOP condition is automatically generated at the end of the transaction. </p>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function should be used only when operating in master mode.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This function registers an internal interrupt handler, which overrides any previously installed handler. </dd></dl>

</div>
</div>
<a id="gac678436710507ceafdba4dbe0585da79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac678436710507ceafdba4dbe0585da79">&#9670;&nbsp;</a></span>i2c_master_receive_buffer_dma()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void i2c_master_receive_buffer_dma </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___i2_c.html#ga3558b2fdf2da82e49c3b523af752b1d9">i2c_dma_channel_pair_t</a>&#160;</td>
          <td class="paramname"><em>dma_channel_pair</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___i2_c.html#ga678dc6024a1d54d4709c78d5e64e9974">i2c_complete_cb_t</a>&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Receive multiple bytes from I2C bus using DMA. </p>
<p>Shortcut for calling <a class="el" href="group___i2_c.html#ga115bca9770b39d69522b5e8c8a62accf" title="Prepares I2C DMA for transfer. ">i2c_prepare_dma()</a> and <a class="el" href="group___i2_c.html#ga6c6a338bfdf17e2c6b0f21746976b74e" title="Starts DMA transfer. ">i2c_dma_start()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dma_channel_pair</td><td>DMA channel </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">data</td><td>Buffer to put data read from I2C bus </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Length of the data buffer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb</td><td>Callback for receive completed </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb_data</td><td>Data to pass to cb </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>Possible values for flags are: <p class="starttd"><a class="el" href="group___i2_c.html#gga61dadd085c1777f559549e05962b2c9ea73a0b58cd5b685a9a417c09cc4dd1129" title="No special command for the operation. ">I2C_F_NONE</a><br />
 This flag can be used for consecutive calls where the transaction can resume without stop/start conditions in between. In case of DA14585 STOP condition is automatically generated at the end of the transaction.</p>
<p class="endtd"><a class="el" href="group___i2_c.html#gga61dadd085c1777f559549e05962b2c9eab37107388b51bbb77fab6bf7e88bcc2e" title="Add stop condition after read or write. ">I2C_F_ADD_STOP</a><br />
 STOP condition will be generated at the end of the transaction. This flag has no effect in DA14585/6 since STOP condition is automatically generated at the end of the transaction. </p>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function should be used only when operating in master mode. </dd></dl>

</div>
</div>
<a id="gadf0a0f5a2dfdfdc4da6f3e1af6acc96e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadf0a0f5a2dfdfdc4da6f3e1af6acc96e">&#9670;&nbsp;</a></span>i2c_master_receive_buffer_sync()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t i2c_master_receive_buffer_sync </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___i2_c.html#gaef40399c7569e3b745df70b86b7107bd">i2c_abort_t</a> *&#160;</td>
          <td class="paramname"><em>abrt_code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read multiple bytes from I2C slave synchronously. </p>
<p>This function will read multiple bytes from bus taking care of RX FIFO control. This call blocks until the operation completes. The operation completes when the complete buffer is filled, or in case of a failure. Failures are cleared by the function before returning.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">data</td><td>Address of the buffer where data are stored </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Length of the data buffer </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">abrt_code</td><td>If not NULL, the status of the operation </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>Possible values for flags are: <p class="starttd"><a class="el" href="group___i2_c.html#gga61dadd085c1777f559549e05962b2c9ea73a0b58cd5b685a9a417c09cc4dd1129" title="No special command for the operation. ">I2C_F_NONE</a><br />
 This flag can be used for consecutive calls where the transaction can resume without stop/start conditions in between. In case of DA14585 STOP condition is automatically generated at the end of the transaction.</p>
<p class="endtd"><a class="el" href="group___i2_c.html#gga61dadd085c1777f559549e05962b2c9eab37107388b51bbb77fab6bf7e88bcc2e" title="Add stop condition after read or write. ">I2C_F_ADD_STOP</a><br />
 STOP condition will be generated at the end of the transaction. This flag has no effect in DA14585/6 since STOP condition is automatically generated at the end of the transaction. </p>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes read</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function should be used only when operating in master mode. </dd></dl>

</div>
</div>
<a id="gaacfd26c9c34f86eaab274eaa0618a092"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaacfd26c9c34f86eaab274eaa0618a092">&#9670;&nbsp;</a></span>i2c_master_transmit_buffer_async()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void i2c_master_transmit_buffer_async </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___i2_c.html#ga678dc6024a1d54d4709c78d5e64e9974">i2c_complete_cb_t</a>&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write multiple bytes to I2C slave asynchronously. </p>
<p>Writes array of data to a slave device on the I2C bus via the TX FIFO. This call is non-blocking and specified callback is called upon completion, with the operation status. In case of failure the failure cause must be read from the cb by calling <a class="el" href="group___i2_c.html#ga19404904f0fe5f700e6ca2f32127b1f2" title="Get abort source. ">i2c_get_abort_source()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Address of the buffer containing the data to write </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Length of the data buffer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb</td><td>Callback to be called upon completion </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb_data</td><td>Data to pass to cb </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>Possible values for flags are: <p class="starttd"><a class="el" href="group___i2_c.html#gga61dadd085c1777f559549e05962b2c9ea73a0b58cd5b685a9a417c09cc4dd1129" title="No special command for the operation. ">I2C_F_NONE</a><br />
 The callback will be called as soon as the last byte of data is written to the Tx FIFO. Possible Tx failure after this point must be checked by the caller. This flag can be used for consecutive calls where the transaction can resume without stop/start conditions in between. In case of DA14585 STOP condition is automatically generated at the end of the transaction.</p>
<p><a class="el" href="group___i2_c.html#gga61dadd085c1777f559549e05962b2c9eadfe3b147312a9af12b252fe79e0920ae" title="Operation will wait until stop condition occurs. ">I2C_F_WAIT_FOR_STOP</a><br />
 The callback will be called when all bytes have been transmitted and a STOP condition has been generated.</p>
<p class="endtd"><a class="el" href="group___i2_c.html#gga61dadd085c1777f559549e05962b2c9eab37107388b51bbb77fab6bf7e88bcc2e" title="Add stop condition after read or write. ">I2C_F_ADD_STOP</a><br />
 STOP condition will be generated at the end of the transaction. This flag has no effect in DA14585/6 since STOP condition is automatically generated at the end of the transaction. The callback will be called as soon as the last byte of data is written to the Tx FIFO. Possible Tx failure after this point must be checked by the caller. </p>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function should be used only when operating in master mode.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This function registers an internal interrupt handler, which overrides any previously installed handler. </dd></dl>

</div>
</div>
<a id="ga461b4bfce9b764311bf938c6292f326e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga461b4bfce9b764311bf938c6292f326e">&#9670;&nbsp;</a></span>i2c_master_transmit_buffer_dma()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void i2c_master_transmit_buffer_dma </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___i2_c.html#ga3558b2fdf2da82e49c3b523af752b1d9">i2c_dma_channel_pair_t</a>&#160;</td>
          <td class="paramname"><em>dma_channel_pair</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___i2_c.html#ga678dc6024a1d54d4709c78d5e64e9974">i2c_complete_cb_t</a>&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transmit multiple bytes on I2C bus using DMA. </p>
<p>Shortcut for calling <a class="el" href="group___i2_c.html#ga115bca9770b39d69522b5e8c8a62accf" title="Prepares I2C DMA for transfer. ">i2c_prepare_dma()</a> and <a class="el" href="group___i2_c.html#ga6c6a338bfdf17e2c6b0f21746976b74e" title="Starts DMA transfer. ">i2c_dma_start()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dma_channel_pair</td><td>DMA channel </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>buffer to write data to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>length of the data buffer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb</td><td>callback for transmit completed </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb_data</td><td>Data to pass to cb </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>Possible values for flags are: <p class="starttd"><a class="el" href="group___i2_c.html#gga61dadd085c1777f559549e05962b2c9ea73a0b58cd5b685a9a417c09cc4dd1129" title="No special command for the operation. ">I2C_F_NONE</a><br />
 The cb will be called as soon as the last byte of data is written to the Tx FIFO. Possible Tx failure after this point must be checked by the caller. This flag can be used for consecutive calls where the transaction can resume without stop/start conditions in between. In case of DA14585 STOP condition is automatically generated at the end of the transaction.</p>
<p><a class="el" href="group___i2_c.html#gga61dadd085c1777f559549e05962b2c9eadfe3b147312a9af12b252fe79e0920ae" title="Operation will wait until stop condition occurs. ">I2C_F_WAIT_FOR_STOP</a><br />
 The callback will be called when all bytes have been transmitted and a STOP condition has been generated.</p>
<p class="endtd"><a class="el" href="group___i2_c.html#gga61dadd085c1777f559549e05962b2c9eab37107388b51bbb77fab6bf7e88bcc2e" title="Add stop condition after read or write. ">I2C_F_ADD_STOP</a><br />
 STOP condition will be generated at the end of the transaction. This flag has no effect in DA14585/6 since STOP condition is automatically generated at the end of the transaction. </p>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function should be used only when operating in master mode. </dd></dl>

</div>
</div>
<a id="ga701ada9b4f01a66f2ab1f85382c3c1e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga701ada9b4f01a66f2ab1f85382c3c1e0">&#9670;&nbsp;</a></span>i2c_master_transmit_buffer_sync()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t i2c_master_transmit_buffer_sync </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___i2_c.html#gaef40399c7569e3b745df70b86b7107bd">i2c_abort_t</a> *&#160;</td>
          <td class="paramname"><em>abrt_code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write multiple bytes to I2C slave synchronously. </p>
<p>Writes array of data to a slave device on the I2C bus via the TX FIFO. This call blocks until the operation completes. In case of failure the function stores the Tx error code to the abrt_code parameter -if provided- and clears the Tx Abort register.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Address of the buffer containing the data to write </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Length of data buffer </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">abrt_code</td><td>If not NULL, the status of the operation </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>Possible values for flags are: <p class="starttd"><a class="el" href="group___i2_c.html#gga61dadd085c1777f559549e05962b2c9ea73a0b58cd5b685a9a417c09cc4dd1129" title="No special command for the operation. ">I2C_F_NONE</a><br />
 The function will return as soon as the last byte of data is written to the Tx FIFO. Possible Tx failure after this point must be checked by the caller. This flag can be used for consecutive calls where the transaction can resume without stop/start conditions in between. In case of DA14585 STOP condition is automatically generated at the end of the transaction.</p>
<p><a class="el" href="group___i2_c.html#gga61dadd085c1777f559549e05962b2c9eadfe3b147312a9af12b252fe79e0920ae" title="Operation will wait until stop condition occurs. ">I2C_F_WAIT_FOR_STOP</a><br />
 The function will return only when all bytes have been transmitted and a STOP condition has been generated.</p>
<p class="endtd"><a class="el" href="group___i2_c.html#gga61dadd085c1777f559549e05962b2c9eab37107388b51bbb77fab6bf7e88bcc2e" title="Add stop condition after read or write. ">I2C_F_ADD_STOP</a><br />
 STOP condition will be generated at the end of the transaction. This flag has no effect in DA14585/6 since STOP condition is automatically generated at the end of the transaction. The function will return as soon as the last byte of data is written to the Tx FIFO. Possible Tx failure after this point must be checked by the caller. </p>
</td></tr>
  </table>
  </dd>
</dl>
<p>This can be used to retrieve source of TX_ABORT interrupt. TX FIFO is flushed and remains in this state until cleared using <a class="el" href="group___i2_c.html#gab3093a20c41758257e74f463159a12bc" title="Reset TX_ABORT interrupt state. ">i2c_reset_int_tx_abort()</a>. </p><dl class="section return"><dt>Returns</dt><dd>The number of bytes written to the Tx FIFO. It is strongly recommended to check the value of abrt_code to make sure that the number of bytes returned were actually transmitted to the I2C bus.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function should be used only when operating in master mode. </dd></dl>

</div>
</div>
<a id="ga115bca9770b39d69522b5e8c8a62accf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga115bca9770b39d69522b5e8c8a62accf">&#9670;&nbsp;</a></span>i2c_prepare_dma()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void i2c_prepare_dma </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___i2_c.html#ga3558b2fdf2da82e49c3b523af752b1d9">i2c_dma_channel_pair_t</a>&#160;</td>
          <td class="paramname"><em>dma_channel_pair</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___i2_c.html#gac688b2325cca3cdc2d76e35fb7199889">i2c_dma_transfer_t</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___i2_c.html#ga678dc6024a1d54d4709c78d5e64e9974">i2c_complete_cb_t</a>&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prepares I2C DMA for transfer. </p>
<p>This function prepares DMA for DMA transfer</p>
<p><code>channel</code> specifies either of channels in RX/TX pair used for transfer, i.e. channel=I2C_DMA_CHANNEL_PAIR_1 means channels 0 and 1 will be used, channel=I2C_DMA_CHANNEL_PAIR_2 means channels 2 and 3 will be used and so on. Once DMA is prepared, no other application should make changes to either of channels.</p>
<p><code>data</code> buffer elements are 16-bit wide, this high byte should be 0 for writing and discarded when reading.</p>
<p>Callback is called once DMA transfer between buffer and RX/TX FIFOs is completed which means that there could still be activity on I2C bus. Application can check when transfer is completed using other means, i.e. STOP_DETECTED interrupt.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dma_channel_pair</td><td>DMA channel pair </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Buffer to read from or write </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Length of data buffer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>Type of transfer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb</td><td>Callback for transfer completed </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb_data</td><td>Data to pass to cb </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>Possible values for flags are: <p class="starttd"><a class="el" href="group___i2_c.html#gga61dadd085c1777f559549e05962b2c9ea73a0b58cd5b685a9a417c09cc4dd1129" title="No special command for the operation. ">I2C_F_NONE</a><br />
 The callback will be called as soon as the last byte of data is written to the Tx FIFO. Possible Tx failure after this point must be checked by the caller. This flag can be used for consecutive calls where the transaction can resume without stop/start conditions in between. In case of DA14585 STOP condition is automatically generated at the end of the transaction.</p>
<p><a class="el" href="group___i2_c.html#gga61dadd085c1777f559549e05962b2c9eadfe3b147312a9af12b252fe79e0920ae" title="Operation will wait until stop condition occurs. ">I2C_F_WAIT_FOR_STOP</a><br />
 The callback will be called when all bytes have been transmitted and a STOP condition has been generated.</p>
<p class="endtd"><a class="el" href="group___i2_c.html#gga61dadd085c1777f559549e05962b2c9eab37107388b51bbb77fab6bf7e88bcc2e" title="Add stop condition after read or write. ">I2C_F_ADD_STOP</a><br />
 STOP condition will be generated at the end of the transaction. This flag has no effect in DA14585/6 since STOP condition is automatically generated at the end of the transaction. </p>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gafabf674fb0a1f15d761e1cade43a1777"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafabf674fb0a1f15d761e1cade43a1777">&#9670;&nbsp;</a></span>i2c_read_byte()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_FORCEINLINE uint8_t i2c_read_byte </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read single byte from RX FIFO. </p>
<p>It is caller's responsibility to ensure there is data to read in RX FIFO before calling this function by checking either <a class="el" href="group___i2_c.html#ga041565eaf33cf5a741573958f37836f7" title="Get number of bytes in RX FIFO. ">i2c_get_rx_fifo_level()</a> or i2c_rx_fifo_not_empty().</p>
<p>This function can be used in both master and slave modes.</p>
<dl class="section return"><dt>Returns</dt><dd>read byte</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___i2_c.html#ga041565eaf33cf5a741573958f37836f7" title="Get number of bytes in RX FIFO. ">i2c_get_rx_fifo_level</a> </dd>
<dd>
i2c_rx_fifo_not_empty </dd></dl>

</div>
</div>
<a id="gada439eb78303e8d9fb8085e6e1b59dcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gada439eb78303e8d9fb8085e6e1b59dcb">&#9670;&nbsp;</a></span>i2c_register_int()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void i2c_register_int </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___i2_c.html#ga27e69e4d2343eb297877e1894ff2df34">i2c_interrupt_cb_t</a>&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register interrupt handler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cb</td><td>callback function </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mask</td><td>initial bitmask of requested interrupt events </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gacaa348818829b078d6033406956040c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacaa348818829b078d6033406956040c9">&#9670;&nbsp;</a></span>i2c_release()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void i2c_release </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disable I2C controller and clock. </p>

</div>
</div>
<a id="ga06743d3a41983ab061e6892ba090d9c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga06743d3a41983ab061e6892ba090d9c7">&#9670;&nbsp;</a></span>i2c_reset_abort_source()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void i2c_reset_abort_source </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reset abort source. </p>
<p>This clears TX_ABORT interrupt status and unlocks TX FIFO.</p>
<dl class="section note"><dt>Note</dt><dd>this is an alias for <a class="el" href="group___i2_c.html#gab3093a20c41758257e74f463159a12bc" title="Reset TX_ABORT interrupt state. ">i2c_reset_int_tx_abort()</a> </dd></dl>

</div>
</div>
<a id="gac4fcfc2bf69cac71bcd42748d37cfe38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac4fcfc2bf69cac71bcd42748d37cfe38">&#9670;&nbsp;</a></span>i2c_reset_int_activity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_FORCEINLINE void i2c_reset_int_activity </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reset ACTIVITY interrupt state. </p>
<p>Should be used to reset ACTIVITY interrupt. </p>

</div>
</div>
<a id="gaccd7592c4fbb6ac1267805dd55371a66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaccd7592c4fbb6ac1267805dd55371a66">&#9670;&nbsp;</a></span>i2c_reset_int_all()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_FORCEINLINE void i2c_reset_int_all </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reset all interrupt state. </p>
<p>This does reset all interrupts which can be reset by software and TX_ABORT status.</p>
<dl class="section warning"><dt>Warning</dt><dd>Although this also clears TX_ABORT it does not reset flushed state on TX FIFO. This has to be cleared manually using <a class="el" href="group___i2_c.html#ga06743d3a41983ab061e6892ba090d9c7" title="Reset abort source. ">i2c_reset_abort_source()</a>. </dd></dl>

</div>
</div>
<a id="ga7523b9932b2f087f21e38be40f41bec7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7523b9932b2f087f21e38be40f41bec7">&#9670;&nbsp;</a></span>i2c_reset_int_gen_call()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_FORCEINLINE void i2c_reset_int_gen_call </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reset GENERAL_CALL interrupt state. </p>
<p>Should be used to reset GENERAL_CALL interrupt. </p>

</div>
</div>
<a id="gaaa2e710cd63a6bd777bc7f5469ce7dcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaa2e710cd63a6bd777bc7f5469ce7dcb">&#9670;&nbsp;</a></span>i2c_reset_int_read_request()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_FORCEINLINE void i2c_reset_int_read_request </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reset READ_REQUEST interrupt state. </p>
<p>Should be used to reset READ_REQUEST interrupt. </p>

</div>
</div>
<a id="gadc298e6b24294e2b2413a707d78c409c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadc298e6b24294e2b2413a707d78c409c">&#9670;&nbsp;</a></span>i2c_reset_int_rx_done()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_FORCEINLINE void i2c_reset_int_rx_done </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reset RX_DONE interrupt state. </p>
<p>Should be used to reset RX_DONE interrupt. </p>

</div>
</div>
<a id="ga03ea6baee64f5c7785868f9e931321f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga03ea6baee64f5c7785868f9e931321f5">&#9670;&nbsp;</a></span>i2c_reset_int_rx_overflow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_FORCEINLINE void i2c_reset_int_rx_overflow </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reset RX_OVERFLOW interrupt state. </p>
<p>Should be used to reset RX_OVERFLOW interrupt. </p>

</div>
</div>
<a id="ga90c34ade55b4489cee09bcd3c4c7b004"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga90c34ade55b4489cee09bcd3c4c7b004">&#9670;&nbsp;</a></span>i2c_reset_int_rx_underflow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_FORCEINLINE void i2c_reset_int_rx_underflow </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reset RX_UNDERFLOW interrupt state. </p>
<p>Should be used to reset RX_UNDERFLOW interrupt. </p>

</div>
</div>
<a id="ga4a508adaaf88a5c293f1ba6473f69aee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4a508adaaf88a5c293f1ba6473f69aee">&#9670;&nbsp;</a></span>i2c_reset_int_start_detected()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_FORCEINLINE void i2c_reset_int_start_detected </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reset START_DETECTED interrupt state. </p>
<p>Should be used to reset START_DETECTED interrupt. </p>

</div>
</div>
<a id="gaa55964b5f006b61f862dd412e8aa515b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa55964b5f006b61f862dd412e8aa515b">&#9670;&nbsp;</a></span>i2c_reset_int_stop_detected()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_FORCEINLINE void i2c_reset_int_stop_detected </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reset STOP_DETECTED interrupt state. </p>
<p>Should be used to reset STOP_DETECTED interrupt. </p>

</div>
</div>
<a id="gab3093a20c41758257e74f463159a12bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab3093a20c41758257e74f463159a12bc">&#9670;&nbsp;</a></span>i2c_reset_int_tx_abort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_FORCEINLINE void i2c_reset_int_tx_abort </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reset TX_ABORT interrupt state. </p>
<p>Should be used to reset TX_ABORT interrupt. </p>

</div>
</div>
<a id="ga93f296885fedf36d6fa91669974c0bd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga93f296885fedf36d6fa91669974c0bd9">&#9670;&nbsp;</a></span>i2c_reset_int_tx_overflow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_FORCEINLINE void i2c_reset_int_tx_overflow </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reset TX_OVERFLOW interrupt state. </p>
<p>Should be used to reset TX_OVERFLOW interrupt. </p>

</div>
</div>
<a id="ga523a126795e301f3ebe0c9f889b6252b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga523a126795e301f3ebe0c9f889b6252b">&#9670;&nbsp;</a></span>i2c_set_clock_status()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_FORCEINLINE void i2c_set_clock_status </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___i2_c.html#ga489a90df00c3703b26d667dbe952b34a">i2c_clock_t</a>&#160;</td>
          <td class="paramname"><em>status</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set I2C clock status. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">status</td><td>for clock </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae55e2a1735c775963b497ddb5d09023a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae55e2a1735c775963b497ddb5d09023a">&#9670;&nbsp;</a></span>i2c_set_controller_status()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_FORCEINLINE void i2c_set_controller_status </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___i2_c.html#ga5bdf6025825018e3fb3ed40081433879">i2c_controller_t</a>&#160;</td>
          <td class="paramname"><em>status</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set I2C controller status. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">status</td><td>Enable or Disable I2C controller </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga92eb7f6635986a23051435e6af7b814a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga92eb7f6635986a23051435e6af7b814a">&#9670;&nbsp;</a></span>i2c_set_general_call_ack_enabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_FORCEINLINE void i2c_set_general_call_ack_enabled </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ack</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set support for general call acknowledgment. </p>
<p>When enabled, controller will send ACK for general call address. This applies only to controller working in slave mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ack</td><td>acknowledgment status </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8cec46af7351e65ab3d79a14dd3462f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8cec46af7351e65ab3d79a14dd3462f4">&#9670;&nbsp;</a></span>i2c_set_general_call_enabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_FORCEINLINE void i2c_set_general_call_enabled </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enabled</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set whether General Call should be used to address slaves. </p>
<p>Can be only set when controller is disabled. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">enabled</td><td>General Call status to be set </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gafbfbce6b4b6bbd86cb30426b2fe42102"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafbfbce6b4b6bbd86cb30426b2fe42102">&#9670;&nbsp;</a></span>i2c_set_int_mask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_FORCEINLINE void i2c_set_int_mask </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>mask</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set I2C interrupt mask. </p>
<p>This register is active low; a value of 0 masks the interrupt, whereas a value of 1 unmasks the interrupt.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mask</td><td>bitmask of requested interrupt events </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf67bc82c706451c1afd5ba8864cabf43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf67bc82c706451c1afd5ba8864cabf43">&#9670;&nbsp;</a></span>i2c_set_mode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_FORCEINLINE void i2c_set_mode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___i2_c.html#gac1e2996ebee909590af8e3cc1c316c25">i2c_mode_t</a>&#160;</td>
          <td class="paramname"><em>mode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set I2C controller mode. </p>
<p>Can be only set when controller is disabled. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>mode to be set </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5bca8b2e12970c2ecd653715494cba1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5bca8b2e12970c2ecd653715494cba1d">&#9670;&nbsp;</a></span>i2c_set_restart_status()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_FORCEINLINE void i2c_set_restart_status </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___i2_c.html#gaf7bd376b040c7c04820bdc6abf3a9a7c">i2c_restart_t</a>&#160;</td>
          <td class="paramname"><em>restart</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set whether RESTART conditions may be sent when acting as master. </p>
<p>Can be only set when controller is disabled. When the RESTART is disabled master is incapable of performing a read operation with a 10-bit address. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">restart</td><td>RESTART status to be set </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga2cbfc9add48d0ce2f18089ff8b4eae14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2cbfc9add48d0ce2f18089ff8b4eae14">&#9670;&nbsp;</a></span>i2c_set_rx_fifo_threshold()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_FORCEINLINE void i2c_set_rx_fifo_threshold </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set threshold level on RX FIFO. </p>
<p>An interrupt will be generated once number of entries in RX FIFO is greater than <code>level</code>. The valid range is 0-31.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">level</td><td>fifo level threshold </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac230641c51613d45ee0170e3134efd80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac230641c51613d45ee0170e3134efd80">&#9670;&nbsp;</a></span>i2c_set_slave_address()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_FORCEINLINE void i2c_set_slave_address </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>address</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set slave address in slave mode. </p>
<p>Can be only set when controller is disabled. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>slave address </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga13d1ece785bf7604734c6e1d0b178fb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga13d1ece785bf7604734c6e1d0b178fb7">&#9670;&nbsp;</a></span>i2c_set_slave_addressing_mode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_FORCEINLINE void i2c_set_slave_addressing_mode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___i2_c.html#ga65b8e8a3eb198a1aa5fac5639a46e8cb">i2c_addressing_t</a>&#160;</td>
          <td class="paramname"><em>addr_mode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set slave addressing mode in slave mode. </p>
<p>Can be only set when controller is disabled. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">addr_mode</td><td>mode of addressing </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga595151c3516c042956d9f4f8e05a0c47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga595151c3516c042956d9f4f8e05a0c47">&#9670;&nbsp;</a></span>i2c_set_speed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_FORCEINLINE void i2c_set_speed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___i2_c.html#ga6e6a870f98abb8cffa95373b69fb8243">i2c_speed_t</a>&#160;</td>
          <td class="paramname"><em>speed</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set I2C interface bus speed. </p>
<p>Can be only set when controller is disabled. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">speed</td><td>speed to be set </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaec7ae6466df5d40cdd8e63b422f1c10c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaec7ae6466df5d40cdd8e63b422f1c10c">&#9670;&nbsp;</a></span>i2c_set_target_address()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_FORCEINLINE void i2c_set_target_address </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>address</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set target slave address in master mode. </p>
<p>Can be only set when controller is disabled. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>target(slave) address </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1a43c4a223d798f3abe9fa6657bb3509"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1a43c4a223d798f3abe9fa6657bb3509">&#9670;&nbsp;</a></span>i2c_set_target_addressing_mode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_FORCEINLINE void i2c_set_target_addressing_mode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___i2_c.html#ga65b8e8a3eb198a1aa5fac5639a46e8cb">i2c_addressing_t</a>&#160;</td>
          <td class="paramname"><em>addr_mode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set target slave addressing mode in master mode. </p>
<p>Can be only set when controller is disabled. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">addr_mode</td><td>mode of addressing </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga2c77916d6a1270e3a1e2bfcdc51a5c79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2c77916d6a1270e3a1e2bfcdc51a5c79">&#9670;&nbsp;</a></span>i2c_set_tx_fifo_threshold()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_FORCEINLINE void i2c_set_tx_fifo_threshold </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set threshold level on TX FIFO. </p>
<p>An interrupt will be generated once number of entries in TX FIFO is less or equal to <code>level</code>. The valid range is 0-31.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">level</td><td>fifo level threshold </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga98d55f19c685fce01ff63e3565add6ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga98d55f19c685fce01ff63e3565add6ff">&#9670;&nbsp;</a></span>i2c_setup_master()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void i2c_setup_master </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___i2_c.html#gaf7bd376b040c7c04820bdc6abf3a9a7c">i2c_restart_t</a>&#160;</td>
          <td class="paramname"><em>restart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___i2_c.html#ga65b8e8a3eb198a1aa5fac5639a46e8cb">i2c_addressing_t</a>&#160;</td>
          <td class="paramname"><em>addr_mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>target_addr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Setup controller for operation in master mode. </p>
<p>Shortcut for calling <a class="el" href="group___i2_c.html#gaf67bc82c706451c1afd5ba8864cabf43" title="Set I2C controller mode. ">i2c_set_mode()</a>, <a class="el" href="group___i2_c.html#ga1a43c4a223d798f3abe9fa6657bb3509" title="Set target slave addressing mode in master mode. ">i2c_set_target_addressing_mode()</a> and <a class="el" href="group___i2_c.html#gaec7ae6466df5d40cdd8e63b422f1c10c" title="Set target slave address in master mode. ">i2c_set_target_address()</a>.</p>
<p>Can be only set when controller is disabled. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">restart</td><td>enable restart condition </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">addr_mode</td><td>mode of addressing </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">target_addr</td><td>slave address </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0d5b9d902befb2354ef90fd25538be20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0d5b9d902befb2354ef90fd25538be20">&#9670;&nbsp;</a></span>i2c_setup_slave()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void i2c_setup_slave </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___i2_c.html#ga65b8e8a3eb198a1aa5fac5639a46e8cb">i2c_addressing_t</a>&#160;</td>
          <td class="paramname"><em>addr_mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>addr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Setup controller for operation in slave mode. </p>
<p>Shortcut for calling <a class="el" href="group___i2_c.html#gaf67bc82c706451c1afd5ba8864cabf43" title="Set I2C controller mode. ">i2c_set_mode()</a>, <a class="el" href="group___i2_c.html#ga13d1ece785bf7604734c6e1d0b178fb7" title="Set slave addressing mode in slave mode. ">i2c_set_slave_addressing_mode()</a> and <a class="el" href="group___i2_c.html#gac230641c51613d45ee0170e3134efd80" title="Set slave address in slave mode. ">i2c_set_slave_address()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">addr_mode</td><td>mode of addressing </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>slave address </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga36713e5d8a8273d7c40c5541df68285a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga36713e5d8a8273d7c40c5541df68285a">&#9670;&nbsp;</a></span>i2c_slave_receive_buffer_async()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void i2c_slave_receive_buffer_async </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___i2_c.html#ga678dc6024a1d54d4709c78d5e64e9974">i2c_complete_cb_t</a>&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Receive multiple bytes from I2C master asynchronously. </p>
<p>This function will receive multiple bytes from master taking care of RX FIFO control. This call is non-blocking and specified callback is called upon completion, with the operation status. The operation completes when the complete buffer is filled, or in case of a failure. In case of failure the failure cause must be read from the cb by calling <a class="el" href="group___i2_c.html#ga19404904f0fe5f700e6ca2f32127b1f2" title="Get abort source. ">i2c_get_abort_source()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">data</td><td>Address of the buffer where data are stored </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Length of the data buffer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb</td><td>Callback to be called upon completion </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb_data</td><td>Data to pass to cb</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function should be used only when operating in slave mode. </dd></dl>

</div>
</div>
<a id="gabb52af07e5c9a926fb598b9bfd521004"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabb52af07e5c9a926fb598b9bfd521004">&#9670;&nbsp;</a></span>i2c_slave_receive_buffer_dma()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void i2c_slave_receive_buffer_dma </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___i2_c.html#ga3558b2fdf2da82e49c3b523af752b1d9">i2c_dma_channel_pair_t</a>&#160;</td>
          <td class="paramname"><em>dma_channel_pair</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___i2_c.html#ga678dc6024a1d54d4709c78d5e64e9974">i2c_complete_cb_t</a>&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Receive multiple bytes from I2C bus using DMA. </p>
<p>Shortcut for calling <a class="el" href="group___i2_c.html#ga115bca9770b39d69522b5e8c8a62accf" title="Prepares I2C DMA for transfer. ">i2c_prepare_dma()</a> and <a class="el" href="group___i2_c.html#ga6c6a338bfdf17e2c6b0f21746976b74e" title="Starts DMA transfer. ">i2c_dma_start()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dma_channel_pair</td><td>DMA channel </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">data</td><td>Buffer to put data read from I2C bus </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Length of data buffer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb</td><td>Callback for receive completed </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb_data</td><td>Data to pass to cb</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function should be used only when operating in slave mode. </dd></dl>

</div>
</div>
<a id="ga5f550ab16d303d20984d810b6b60333d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5f550ab16d303d20984d810b6b60333d">&#9670;&nbsp;</a></span>i2c_slave_receive_buffer_sync()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t i2c_slave_receive_buffer_sync </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Receive multiple bytes from I2C master synchronously. </p>
<p>This function will receive multiple bytes from master taking care of RX FIFO control. This call blocks until the operation completes. The operation completes when the complete buffer is filled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">data</td><td>Address of the buffer where data are stored </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Length of the data buffer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes read</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function should be used only when operating in slave mode. </dd></dl>

</div>
</div>
<a id="ga6424c4c37d7cb58a42342772e573d3ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6424c4c37d7cb58a42342772e573d3ae">&#9670;&nbsp;</a></span>i2c_slave_transmit_buffer_async()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void i2c_slave_transmit_buffer_async </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___i2_c.html#ga678dc6024a1d54d4709c78d5e64e9974">i2c_complete_cb_t</a>&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transmit multiple bytes to I2C master asynchronously. </p>
<p>Transmit an array of data to a master device on the I2C bus via the TX FIFO. This call is non-blocking and specified callback is called upon completion, with the operation status. In case of failure the failure cause must be read from the cb by calling <a class="el" href="group___i2_c.html#ga19404904f0fe5f700e6ca2f32127b1f2" title="Get abort source. ">i2c_get_abort_source()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Address of the buffer containing the data to write </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Length of the data buffer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb</td><td>Callback to be called upon completion </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb_data</td><td>Data to pass to cb</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function should be used only when operating in slave mode. </dd></dl>

</div>
</div>
<a id="ga2c8c21c0b5059c361bb3ae58748a29be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2c8c21c0b5059c361bb3ae58748a29be">&#9670;&nbsp;</a></span>i2c_slave_transmit_buffer_dma()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void i2c_slave_transmit_buffer_dma </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___i2_c.html#ga3558b2fdf2da82e49c3b523af752b1d9">i2c_dma_channel_pair_t</a>&#160;</td>
          <td class="paramname"><em>dma_channel_pair</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___i2_c.html#ga678dc6024a1d54d4709c78d5e64e9974">i2c_complete_cb_t</a>&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transmit multiple bytes on I2C bus using DMA. </p>
<p>Shortcut for calling <a class="el" href="group___i2_c.html#ga115bca9770b39d69522b5e8c8a62accf" title="Prepares I2C DMA for transfer. ">i2c_prepare_dma()</a> and <a class="el" href="group___i2_c.html#ga6c6a338bfdf17e2c6b0f21746976b74e" title="Starts DMA transfer. ">i2c_dma_start()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dma_channel_pair</td><td>DMA channel </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Buffer to write data to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Length of data buffer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb</td><td>Callback for transmit completed </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb_data</td><td>Data to pass to cb</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function should be used only when operating in slave mode. </dd></dl>

</div>
</div>
<a id="gaa8200d2174371fd44842469867653aff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa8200d2174371fd44842469867653aff">&#9670;&nbsp;</a></span>i2c_slave_transmit_buffer_sync()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t i2c_slave_transmit_buffer_sync </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___i2_c.html#gaef40399c7569e3b745df70b86b7107bd">i2c_abort_t</a> *&#160;</td>
          <td class="paramname"><em>abrt_code</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transmit multiple bytes to I2C master synchronously. </p>
<p>Transmit an array of data to a slave device on the I2C bus via the TX FIFO. This call blocks until the operation completes. In case of failure the function stores the Tx error code to the abrt_code parameter -if provided- and clears the Tx Abort register.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Address of the buffer containing the data to write </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Length of the data buffer </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">abrt_code</td><td>If not NULL, the status of the operation</td></tr>
  </table>
  </dd>
</dl>
<p>This can be used to retrieve source of TX_ABORT interrupt. TX FIFO is flushed and remains in this state until cleared using <a class="el" href="group___i2_c.html#gab3093a20c41758257e74f463159a12bc" title="Reset TX_ABORT interrupt state. ">i2c_reset_int_tx_abort()</a>. </p><dl class="section return"><dt>Returns</dt><dd>The number of bytes written to the Tx FIFO. It is strongly recommended to check the value of abrt_code to make sure that the number of bytes returned were actually transmitted to the I2C bus.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function should be used only when operating in slave mode. </dd></dl>

</div>
</div>
<a id="ga8e0617f68035338884e218a18f778661"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8e0617f68035338884e218a18f778661">&#9670;&nbsp;</a></span>i2c_unregister_int()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void i2c_unregister_int </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unregister interrupt handler. </p>
<p>This function disables all I2C interrupts by masking them. In addition it clears any pending ones on the ARM core. The status of RAW_INTR_STAT_REG remains unchanged. </p>

</div>
</div>
<a id="gaea9ff475e5a350eae2e16f5c7fda14d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaea9ff475e5a350eae2e16f5c7fda14d0">&#9670;&nbsp;</a></span>i2c_write_byte()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_FORCEINLINE void i2c_write_byte </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write single byte into TX FIFO. </p>
<p>It is caller's responsibility to ensure there is free space in TX FIFO before calling this function - either <a class="el" href="group___i2_c.html#gaa20592a0108b29bbe5eeed40e5976b34" title="Check if TX FIFO is not full. ">i2c_is_tx_fifo_not_full()</a> or <a class="el" href="group___i2_c.html#gaec9341515b75c133794c6b697bc3cd91" title="Get number of bytes in TX FIFO. ">i2c_get_tx_fifo_level()</a> can be used for this purpose.</p>
<p>This function can be used in both master and slave modes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>data to write</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>This function does not check for errors during transmission. Use <a class="el" href="group___i2_c.html#ga701ada9b4f01a66f2ab1f85382c3c1e0" title="Write multiple bytes to I2C slave synchronously. ">i2c_master_transmit_buffer_sync()</a> or <a class="el" href="group___i2_c.html#gaacfd26c9c34f86eaab274eaa0618a092" title="Write multiple bytes to I2C slave asynchronously. ">i2c_master_transmit_buffer_async()</a> instead </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri May 9 2025 12:56:14 for DA14535 SDK6 by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
