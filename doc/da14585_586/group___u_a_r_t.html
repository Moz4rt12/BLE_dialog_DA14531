<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DA14585/DA14586 SDK6: UART</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">DA14585/DA14586 SDK6
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> &#124;
<a href="#files">Files</a> &#124;
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">UART<div class="ingroups"><a class="el" href="group___drivers.html">Drivers</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>UART driver API.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:group___u_a_r_t___u_t_i_l_s"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t___u_t_i_l_s.html">UART Driver Utilities</a></td></tr>
<tr class="memdesc:group___u_a_r_t___u_t_i_l_s"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART driver utilities API. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="files"></a>
Files</h2></td></tr>
<tr class="memitem:ext__wakeup__uart_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ext__wakeup__uart_8h.html">ext_wakeup_uart.h</a></td></tr>
<tr class="memdesc:ext__wakeup__uart_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">External wake up via 4W-UART for external processor applications for DA14585/586/531/535 devices. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:uart_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="uart_8h.html">uart.h</a></td></tr>
<tr class="memdesc:uart_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART Low Level Driver for DA14585, DA14586 and DA14531 devices. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structext__wkup__uart__pins__t.html">ext_wkup_uart_pins_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structuart__t.html">uart_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART registers.  <a href="structuart__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structuart__cfg__t.html">uart_cfg_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART configuration structure definition.  <a href="structuart__cfg__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga8d69bf04d07af4fbbab5a8bd291f65ff"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#ga8d69bf04d07af4fbbab5a8bd291f65ff">UART1</a>&#160;&#160;&#160;(<a class="el" href="structuart__t.html">uart_t</a> *)  UART_RBR_THR_DLL_REG</td></tr>
<tr class="memdesc:ga8d69bf04d07af4fbbab5a8bd291f65ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART Base Address.  <a href="#ga8d69bf04d07af4fbbab5a8bd291f65ff">More...</a><br /></td></tr>
<tr class="separator:ga8d69bf04d07af4fbbab5a8bd291f65ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f6bd6eb89ae2eeae97af4207ebe3cde"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#ga7f6bd6eb89ae2eeae97af4207ebe3cde">UART2</a>&#160;&#160;&#160;(<a class="el" href="structuart__t.html">uart_t</a> *)  UART2_RBR_THR_DLL_REG</td></tr>
<tr class="memdesc:ga7f6bd6eb89ae2eeae97af4207ebe3cde"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART2 Base Address.  <a href="#ga7f6bd6eb89ae2eeae97af4207ebe3cde">More...</a><br /></td></tr>
<tr class="separator:ga7f6bd6eb89ae2eeae97af4207ebe3cde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga92d985da6329d3e314a091028c6fc951"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#ga92d985da6329d3e314a091028c6fc951">UART_ID</a>(id)&#160;&#160;&#160;((id) == <a class="el" href="group___u_a_r_t.html#ga8d69bf04d07af4fbbab5a8bd291f65ff">UART1</a> ? 0 : 1)</td></tr>
<tr class="memdesc:ga92d985da6329d3e314a091028c6fc951"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro to get the ID from UART Base Address.  <a href="#ga92d985da6329d3e314a091028c6fc951">More...</a><br /></td></tr>
<tr class="separator:ga92d985da6329d3e314a091028c6fc951"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4dfd8a0416bf7498e942a840df5d80ec"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#ga4dfd8a0416bf7498e942a840df5d80ec">UART_ENV</a>(id)&#160;&#160;&#160;(&amp;uartn_env[((id) == <a class="el" href="group___u_a_r_t.html#ga8d69bf04d07af4fbbab5a8bd291f65ff">UART1</a> ? 0 : 1)])</td></tr>
<tr class="memdesc:ga4dfd8a0416bf7498e942a840df5d80ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro to get the environment from UART ID.  <a href="#ga4dfd8a0416bf7498e942a840df5d80ec">More...</a><br /></td></tr>
<tr class="separator:ga4dfd8a0416bf7498e942a840df5d80ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga198bd0474d370c0b50733b98a4205c65"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#ga198bd0474d370c0b50733b98a4205c65">UART_INTR</a>(id)&#160;&#160;&#160;((id) == <a class="el" href="group___u_a_r_t.html#ga8d69bf04d07af4fbbab5a8bd291f65ff">UART1</a>  ? (UART_IRQn) : (UART2_IRQn))</td></tr>
<tr class="memdesc:ga198bd0474d370c0b50733b98a4205c65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro to get the UART IRQ from UART ID.  <a href="#ga198bd0474d370c0b50733b98a4205c65">More...</a><br /></td></tr>
<tr class="separator:ga198bd0474d370c0b50733b98a4205c65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga37ba06550cb3e2e3082df5d85ea96213"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#ga37ba06550cb3e2e3082df5d85ea96213">BAUD_RATE_DIV</a>(x)&#160;&#160;&#160;((x &gt;&gt; 8) &amp; 0xFFFF)</td></tr>
<tr class="memdesc:ga37ba06550cb3e2e3082df5d85ea96213"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate Baud Rate Divisor.  <a href="#ga37ba06550cb3e2e3082df5d85ea96213">More...</a><br /></td></tr>
<tr class="separator:ga37ba06550cb3e2e3082df5d85ea96213"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab290ff91fc7ac576a8c3050d59291d82"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#gab290ff91fc7ac576a8c3050d59291d82">BAUD_RATE_FRAC</a>(x)&#160;&#160;&#160;(x &amp; 0xFF)</td></tr>
<tr class="memdesc:gab290ff91fc7ac576a8c3050d59291d82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate Baud Rate Fractional part.  <a href="#gab290ff91fc7ac576a8c3050d59291d82">More...</a><br /></td></tr>
<tr class="separator:gab290ff91fc7ac576a8c3050d59291d82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga04a94e06527ed4faa4174427ef008cc2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#ga04a94e06527ed4faa4174427ef008cc2">UART_IID0_FIFOE</a>&#160;&#160;&#160;(0x0001)</td></tr>
<tr class="memdesc:ga04a94e06527ed4faa4174427ef008cc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">FIFO Enable.  <a href="#ga04a94e06527ed4faa4174427ef008cc2">More...</a><br /></td></tr>
<tr class="separator:ga04a94e06527ed4faa4174427ef008cc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a8ce76c89c17aa08a03b76b122c4d3c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#ga7a8ce76c89c17aa08a03b76b122c4d3c">UART_IID1_RFIFOE</a>&#160;&#160;&#160;(0x0002)</td></tr>
<tr class="memdesc:ga7a8ce76c89c17aa08a03b76b122c4d3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">RCVR FIFO Reset.  <a href="#ga7a8ce76c89c17aa08a03b76b122c4d3c">More...</a><br /></td></tr>
<tr class="separator:ga7a8ce76c89c17aa08a03b76b122c4d3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga60ca04adbfa38dc1df82cf2b37c0b501"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#ga60ca04adbfa38dc1df82cf2b37c0b501">UART_IID2_XFIFOR</a>&#160;&#160;&#160;(0x0004)</td></tr>
<tr class="memdesc:ga60ca04adbfa38dc1df82cf2b37c0b501"><td class="mdescLeft">&#160;</td><td class="mdescRight">XMIT FIFO Reset.  <a href="#ga60ca04adbfa38dc1df82cf2b37c0b501">More...</a><br /></td></tr>
<tr class="separator:ga60ca04adbfa38dc1df82cf2b37c0b501"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga67d2eb8177cfbb70307346d0e78f1ec2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#ga67d2eb8177cfbb70307346d0e78f1ec2">UART_IID3_DMAM</a>&#160;&#160;&#160;(0x0008)</td></tr>
<tr class="memdesc:ga67d2eb8177cfbb70307346d0e78f1ec2"><td class="mdescLeft">&#160;</td><td class="mdescRight">DMA Mode.  <a href="#ga67d2eb8177cfbb70307346d0e78f1ec2">More...</a><br /></td></tr>
<tr class="separator:ga67d2eb8177cfbb70307346d0e78f1ec2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9b5ddd24650e9e56570b3d54d8c7d819"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#ga9b5ddd24650e9e56570b3d54d8c7d819">UART_TET</a>&#160;&#160;&#160;(0x0030)</td></tr>
<tr class="memdesc:ga9b5ddd24650e9e56570b3d54d8c7d819"><td class="mdescLeft">&#160;</td><td class="mdescRight">TX Empty Trigger.  <a href="#ga9b5ddd24650e9e56570b3d54d8c7d819">More...</a><br /></td></tr>
<tr class="separator:ga9b5ddd24650e9e56570b3d54d8c7d819"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0817c0cf2ad6f72810fa1a78565b3022"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#ga0817c0cf2ad6f72810fa1a78565b3022">UART_FIFOSE_RT</a>&#160;&#160;&#160;(0x00C0)</td></tr>
<tr class="memdesc:ga0817c0cf2ad6f72810fa1a78565b3022"><td class="mdescLeft">&#160;</td><td class="mdescRight">RCVR Trigger.  <a href="#ga0817c0cf2ad6f72810fa1a78565b3022">More...</a><br /></td></tr>
<tr class="separator:ga0817c0cf2ad6f72810fa1a78565b3022"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga587d4439909898b9ae38e9aca950ae02"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#ga587d4439909898b9ae38e9aca950ae02">uart_cb_t</a>) (uint16_t data_cnt)</td></tr>
<tr class="memdesc:ga587d4439909898b9ae38e9aca950ae02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transmit callback type definition.  <a href="#ga587d4439909898b9ae38e9aca950ae02">More...</a><br /></td></tr>
<tr class="separator:ga587d4439909898b9ae38e9aca950ae02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga54e57286e0cd5aa49304eff5ed78156c"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#ga54e57286e0cd5aa49304eff5ed78156c">uart_err_cb_t</a>) (<a class="el" href="structuart__t.html">uart_t</a> *uart, uint8_t uart_err_status)</td></tr>
<tr class="memdesc:ga54e57286e0cd5aa49304eff5ed78156c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Error callback type definition.  <a href="#ga54e57286e0cd5aa49304eff5ed78156c">More...</a><br /></td></tr>
<tr class="separator:ga54e57286e0cd5aa49304eff5ed78156c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:gabd218b2905cb2bad7f9d44912d63be3d"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#gabd218b2905cb2bad7f9d44912d63be3d">UART_BIT_CFG</a> { <a class="el" href="group___u_a_r_t.html#ggabd218b2905cb2bad7f9d44912d63be3dac3ca41d778103dd4f807464e022bea47">UART_BIT_DIS</a> = 0, 
<a class="el" href="group___u_a_r_t.html#ggabd218b2905cb2bad7f9d44912d63be3da6962720bc8dfa29962d1d47ce8c02950">UART_BIT_EN</a> = 1
 }</td></tr>
<tr class="memdesc:gabd218b2905cb2bad7f9d44912d63be3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic enable/disable enum for UART driver.  <a href="group___u_a_r_t.html#gabd218b2905cb2bad7f9d44912d63be3d">More...</a><br /></td></tr>
<tr class="separator:gabd218b2905cb2bad7f9d44912d63be3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0528dc4401f43d2c1ce20479a635c327"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#ga0528dc4401f43d2c1ce20479a635c327">UART_STATUS</a> { <br />
&#160;&#160;<a class="el" href="group___u_a_r_t.html#gga0528dc4401f43d2c1ce20479a635c327adf538d3c816b049a4cb9cceefc43884c">UART_ERR_NO_ERROR</a> = 0, 
<a class="el" href="group___u_a_r_t.html#gga0528dc4401f43d2c1ce20479a635c327adae9d030ead331c9693a5a53e6277726">UART_ERR_BUSY_ERROR</a> = 1, 
<a class="el" href="group___u_a_r_t.html#gga0528dc4401f43d2c1ce20479a635c327ac3222c4accd846f6c1a569b6a347eeb5">UART_ERR_OVERRUN_ERROR</a> = UART_OE, 
<a class="el" href="group___u_a_r_t.html#gga0528dc4401f43d2c1ce20479a635c327a5b74c7bf4dde7c35f5e1dd2d4335ce25">UART_ERR_PARITY_ERROR</a> = UART_PE, 
<br />
&#160;&#160;<a class="el" href="group___u_a_r_t.html#gga0528dc4401f43d2c1ce20479a635c327a5841e1ca9586d48e013f1a6a610535f4">UART_ERR_FRAMING_ERROR</a> = UART_FE, 
<a class="el" href="group___u_a_r_t.html#gga0528dc4401f43d2c1ce20479a635c327a5044b44e72bdb8702767f399bfb876e3">UART_ERR_BREAK_ERROR</a> = UART_BI, 
<a class="el" href="group___u_a_r_t.html#gga0528dc4401f43d2c1ce20479a635c327a67e5c2ab516a138000192857d4769b54">UART_ERR_RX_FIFO_ERROR</a> = UART_RFE
<br />
 }</td></tr>
<tr class="memdesc:ga0528dc4401f43d2c1ce20479a635c327"><td class="mdescLeft">&#160;</td><td class="mdescRight">Status enum for UART driver.  <a href="group___u_a_r_t.html#ga0528dc4401f43d2c1ce20479a635c327">More...</a><br /></td></tr>
<tr class="separator:ga0528dc4401f43d2c1ce20479a635c327"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd8e8830a5d0b31458f1825de0ca1c4e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#gacd8e8830a5d0b31458f1825de0ca1c4e">UART_INT</a> { <br />
&#160;&#160;<a class="el" href="group___u_a_r_t.html#ggacd8e8830a5d0b31458f1825de0ca1c4ea3fd0767497a95f15a101c31e19e2843b">UART_INT_NO_INT_PEND</a> = 1, 
<a class="el" href="group___u_a_r_t.html#ggacd8e8830a5d0b31458f1825de0ca1c4ea7d745437f6ce62a2b0d94776ffd43fb9">UART_INT_THR_EMPTY</a> = 2, 
<a class="el" href="group___u_a_r_t.html#ggacd8e8830a5d0b31458f1825de0ca1c4ea69db21de2d2e7be66976fcd6231397c0">UART_INT_RECEIVED_AVAILABLE</a> = 4, 
<a class="el" href="group___u_a_r_t.html#ggacd8e8830a5d0b31458f1825de0ca1c4ea7aa86ea71f117e40288ab1e201e3221b">UART_INT_RECEIVE_LINE_STAT</a> = 6, 
<br />
&#160;&#160;<a class="el" href="group___u_a_r_t.html#ggacd8e8830a5d0b31458f1825de0ca1c4ea2b463afcd99d695bc7286585fb04977a">UART_INT_BUSY_DETECTED</a> = 7, 
<a class="el" href="group___u_a_r_t.html#ggacd8e8830a5d0b31458f1825de0ca1c4ea44450caa0b760aa1e5ef35b23104b306">UART_INT_TIMEOUT</a> = 12
<br />
 }</td></tr>
<tr class="memdesc:gacd8e8830a5d0b31458f1825de0ca1c4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interrupt Identification codes.  <a href="group___u_a_r_t.html#gacd8e8830a5d0b31458f1825de0ca1c4e">More...</a><br /></td></tr>
<tr class="separator:gacd8e8830a5d0b31458f1825de0ca1c4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2ebef9ab11e56d9d914a270f8a895034"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#ga2ebef9ab11e56d9d914a270f8a895034">UART_BAUDRATE</a> { <br />
&#160;&#160;<a class="el" href="group___u_a_r_t.html#gga2ebef9ab11e56d9d914a270f8a895034a82d65082b6f8df08e8d52ae147256060">UART_BAUDRATE_1000000</a> = 0x000100, 
<a class="el" href="group___u_a_r_t.html#gga2ebef9ab11e56d9d914a270f8a895034a404611687ebff8a0f12677fffd27535b">UART_BAUDRATE_921600</a> = 0x000101, 
<a class="el" href="group___u_a_r_t.html#gga2ebef9ab11e56d9d914a270f8a895034a4d33d08d6ce7d7436722f757b31d669e">UART_BAUDRATE_500000</a> = 0x000200, 
<a class="el" href="group___u_a_r_t.html#gga2ebef9ab11e56d9d914a270f8a895034a045376206230ea6263553424697fbe2e">UART_BAUDRATE_460800</a> = 0x000203, 
<br />
&#160;&#160;<a class="el" href="group___u_a_r_t.html#gga2ebef9ab11e56d9d914a270f8a895034a2655448bc65d60f801362784520b8b7f">UART_BAUDRATE_230400</a> = 0x000405, 
<a class="el" href="group___u_a_r_t.html#gga2ebef9ab11e56d9d914a270f8a895034a8bfbaf4f7fcc3591d3f40fedc503501e">UART_BAUDRATE_115200</a> = 0x00080b, 
<a class="el" href="group___u_a_r_t.html#gga2ebef9ab11e56d9d914a270f8a895034a0a4f1f97b369196795153a10dcc9d5cf">UART_BAUDRATE_57600</a> = 0x001106, 
<a class="el" href="group___u_a_r_t.html#gga2ebef9ab11e56d9d914a270f8a895034a21dd883e9be8390ef1d034edad397167">UART_BAUDRATE_38400</a> = 0x001a01, 
<br />
&#160;&#160;<a class="el" href="group___u_a_r_t.html#gga2ebef9ab11e56d9d914a270f8a895034a60fd45cbdbb32488a06268f504528ce1">UART_BAUDRATE_28800</a> = 0x00220c, 
<a class="el" href="group___u_a_r_t.html#gga2ebef9ab11e56d9d914a270f8a895034a2eacecb72086c5387c99225aa8f63bf7">UART_BAUDRATE_19200</a> = 0x003401, 
<a class="el" href="group___u_a_r_t.html#gga2ebef9ab11e56d9d914a270f8a895034af4ec9a8ee0b6255775d2ecae5f180aa7">UART_BAUDRATE_14400</a> = 0x004507, 
<a class="el" href="group___u_a_r_t.html#gga2ebef9ab11e56d9d914a270f8a895034a643943379183cdf9d8c0dd9f7b5dcd29">UART_BAUDRATE_9600</a> = 0x006803, 
<br />
&#160;&#160;<a class="el" href="group___u_a_r_t.html#gga2ebef9ab11e56d9d914a270f8a895034abe866ffb30dbc65f9090023cf3ac04ea">UART_BAUDRATE_4800</a> = 0x00d005, 
<a class="el" href="group___u_a_r_t.html#gga2ebef9ab11e56d9d914a270f8a895034a647219a441d89f39dcc11a738e294c53">UART_BAUDRATE_2400</a> = 0x01a00b
<br />
 }</td></tr>
<tr class="memdesc:ga2ebef9ab11e56d9d914a270f8a895034"><td class="mdescLeft">&#160;</td><td class="mdescRight">Baud rates dividers The defined values comprise the values of 3 registers: DLH, DLL, DLF.  <a href="group___u_a_r_t.html#ga2ebef9ab11e56d9d914a270f8a895034">More...</a><br /></td></tr>
<tr class="separator:ga2ebef9ab11e56d9d914a270f8a895034"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga24f73385af2d9c46d405402760a30766"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#ga24f73385af2d9c46d405402760a30766">UART_DATABITS</a> { <a class="el" href="group___u_a_r_t.html#gga24f73385af2d9c46d405402760a30766a1689317330cc55b4345c8a6995ce1fad">UART_DATABITS_5</a> = 0, 
<a class="el" href="group___u_a_r_t.html#gga24f73385af2d9c46d405402760a30766ab468f4f38a9d73b03d2eeee413879283">UART_DATABITS_6</a> = 1, 
<a class="el" href="group___u_a_r_t.html#gga24f73385af2d9c46d405402760a30766a941f53895de35cb17c5b5ae5e57a02b9">UART_DATABITS_7</a> = 2, 
<a class="el" href="group___u_a_r_t.html#gga24f73385af2d9c46d405402760a30766af080420d870f7b3917bd59107ac4c153">UART_DATABITS_8</a> = 3
 }</td></tr>
<tr class="memdesc:ga24f73385af2d9c46d405402760a30766"><td class="mdescLeft">&#160;</td><td class="mdescRight">Character format.  <a href="group___u_a_r_t.html#ga24f73385af2d9c46d405402760a30766">More...</a><br /></td></tr>
<tr class="separator:ga24f73385af2d9c46d405402760a30766"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga24fd4dba815fc40fbd8e8c37dbf87c7a"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#ga24fd4dba815fc40fbd8e8c37dbf87c7a">UART_PARITY</a> { <a class="el" href="group___u_a_r_t.html#gga24fd4dba815fc40fbd8e8c37dbf87c7aaa80d2d8ea61454045ebe71d155e85b3d">UART_PARITY_NONE</a> = 0, 
<a class="el" href="group___u_a_r_t.html#gga24fd4dba815fc40fbd8e8c37dbf87c7aad90cc425f5ba447773a44a75be6593e2">UART_PARITY_ODD</a> = 1, 
<a class="el" href="group___u_a_r_t.html#gga24fd4dba815fc40fbd8e8c37dbf87c7aad908a637b1dd23f93b149dd2d8bdfdb8">UART_PARITY_EVEN</a> = 3
 }</td></tr>
<tr class="memdesc:ga24fd4dba815fc40fbd8e8c37dbf87c7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parity.  <a href="group___u_a_r_t.html#ga24fd4dba815fc40fbd8e8c37dbf87c7a">More...</a><br /></td></tr>
<tr class="separator:ga24fd4dba815fc40fbd8e8c37dbf87c7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacbd51ac613ec824eeb73a5b6bf743ca6"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#gacbd51ac613ec824eeb73a5b6bf743ca6">UART_STOPBITS</a> { <a class="el" href="group___u_a_r_t.html#ggacbd51ac613ec824eeb73a5b6bf743ca6ab1c6c3da76951f5a1817859f83ddd9fa">UART_STOPBITS_1</a> = 0, 
<a class="el" href="group___u_a_r_t.html#ggacbd51ac613ec824eeb73a5b6bf743ca6af4b730b061af3ef2004c360c158ffef8">UART_STOPBITS_2</a> = 1
 }</td></tr>
<tr class="memdesc:gacbd51ac613ec824eeb73a5b6bf743ca6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stop bits.  <a href="group___u_a_r_t.html#gacbd51ac613ec824eeb73a5b6bf743ca6">More...</a><br /></td></tr>
<tr class="separator:gacbd51ac613ec824eeb73a5b6bf743ca6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2a2e6711c13f801499299cf273a5e4e6"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#ga2a2e6711c13f801499299cf273a5e4e6">UART_AFCE_CFG</a> { <a class="el" href="group___u_a_r_t.html#gga2a2e6711c13f801499299cf273a5e4e6ac1efdec29ec5a93769ee6b3ebb7f2c9e">UART_AFCE_DIS</a> = 0, 
<a class="el" href="group___u_a_r_t.html#gga2a2e6711c13f801499299cf273a5e4e6adf7761399acd12c42452b11d01493ad3">UART_AFCE_EN</a> = 1
 }</td></tr>
<tr class="memdesc:ga2a2e6711c13f801499299cf273a5e4e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auto flow control.  <a href="group___u_a_r_t.html#ga2a2e6711c13f801499299cf273a5e4e6">More...</a><br /></td></tr>
<tr class="separator:ga2a2e6711c13f801499299cf273a5e4e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d34e34ab58c383449603db0b5cd4e89"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#ga1d34e34ab58c383449603db0b5cd4e89">UART_FIFO_CFG</a> { <a class="el" href="group___u_a_r_t.html#gga1d34e34ab58c383449603db0b5cd4e89a1980b9d1c707c322c73cfecca3e1092a">UART_FIFO_DIS</a> = 0, 
<a class="el" href="group___u_a_r_t.html#gga1d34e34ab58c383449603db0b5cd4e89ae70293a4941e4be08236f415b1532fa1">UART_FIFO_EN</a> = 1
 }</td></tr>
<tr class="memdesc:ga1d34e34ab58c383449603db0b5cd4e89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use FIFO.  <a href="group___u_a_r_t.html#ga1d34e34ab58c383449603db0b5cd4e89">More...</a><br /></td></tr>
<tr class="separator:ga1d34e34ab58c383449603db0b5cd4e89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga56aaf477e65211c6e6858894d1590fd7"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#ga56aaf477e65211c6e6858894d1590fd7">UART_RX_FIFO_LEVEL</a> { <a class="el" href="group___u_a_r_t.html#gga56aaf477e65211c6e6858894d1590fd7ad9cd1fd081c164f6fed9019e67714f2e">UART_RX_FIFO_LEVEL_0</a> = 0, 
<a class="el" href="group___u_a_r_t.html#gga56aaf477e65211c6e6858894d1590fd7acf6f77fab0372d75b7aaa6c519160b5a">UART_RX_FIFO_LEVEL_1</a> = 1, 
<a class="el" href="group___u_a_r_t.html#gga56aaf477e65211c6e6858894d1590fd7ada8efcab12126cb8c92021c17f41a8aa">UART_RX_FIFO_LEVEL_2</a> = 2, 
<a class="el" href="group___u_a_r_t.html#gga56aaf477e65211c6e6858894d1590fd7a04d74c8bc65a13aef3607e74961f26e5">UART_RX_FIFO_LEVEL_3</a> = 3
 }</td></tr>
<tr class="memdesc:ga56aaf477e65211c6e6858894d1590fd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART RX FIFO level. Select the trigger level in the receiver FIFO at which the Received Data Available Interrupt will be generated.  <a href="group___u_a_r_t.html#ga56aaf477e65211c6e6858894d1590fd7">More...</a><br /></td></tr>
<tr class="separator:ga56aaf477e65211c6e6858894d1590fd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga10962da2c5916d3eb7890bab6ed7b3f4"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#ga10962da2c5916d3eb7890bab6ed7b3f4">UART_TX_FIFO_LEVEL</a> { <a class="el" href="group___u_a_r_t.html#gga10962da2c5916d3eb7890bab6ed7b3f4a3349f130d24460a0d818c66cf7cd734e">UART_TX_FIFO_LEVEL_0</a> = 0, 
<a class="el" href="group___u_a_r_t.html#gga10962da2c5916d3eb7890bab6ed7b3f4a3b6d6b02236f159dbfbc7ce5b3338017">UART_TX_FIFO_LEVEL_1</a> = 1, 
<a class="el" href="group___u_a_r_t.html#gga10962da2c5916d3eb7890bab6ed7b3f4a3b91e5a3f0ad215acfd2114f41a41d97">UART_TX_FIFO_LEVEL_2</a> = 2, 
<a class="el" href="group___u_a_r_t.html#gga10962da2c5916d3eb7890bab6ed7b3f4a4e3fe927649eb93b162730b94104396c">UART_TX_FIFO_LEVEL_3</a> = 3
 }</td></tr>
<tr class="memdesc:ga10962da2c5916d3eb7890bab6ed7b3f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART TX FIFO level. Select the empty threshold level at which the THRE Interrupts will be generated.  <a href="group___u_a_r_t.html#ga10962da2c5916d3eb7890bab6ed7b3f4">More...</a><br /></td></tr>
<tr class="separator:ga10962da2c5916d3eb7890bab6ed7b3f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga55de0ec52ddacb716672e99b81eedfef"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#ga55de0ec52ddacb716672e99b81eedfef">UART_DMA_CFG</a> { <a class="el" href="group___u_a_r_t.html#gga55de0ec52ddacb716672e99b81eedfefa1b8df60eb38bbb0a887c9c167f473500">UART_DMA_DISABLE</a> = 0, 
<a class="el" href="group___u_a_r_t.html#gga55de0ec52ddacb716672e99b81eedfefa9726c6224c09fac87c81d71a192fc032">UART_DMA_ENABLE</a> = 1
 }</td></tr>
<tr class="memdesc:ga55de0ec52ddacb716672e99b81eedfef"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART DMA support.  <a href="group___u_a_r_t.html#ga55de0ec52ddacb716672e99b81eedfef">More...</a><br /></td></tr>
<tr class="separator:ga55de0ec52ddacb716672e99b81eedfef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8fc237bc57dd45252e96589aa1a1e7f6"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#ga8fc237bc57dd45252e96589aa1a1e7f6">UART_DMA_CHANNEL_CFG</a> { <a class="el" href="group___u_a_r_t.html#gga8fc237bc57dd45252e96589aa1a1e7f6aeb45e06b6f755e24127c3568d56edc0f">UART_DMA_CHANNEL_01</a> = 0, 
<a class="el" href="group___u_a_r_t.html#gga8fc237bc57dd45252e96589aa1a1e7f6a642d7c49dc907aafd21d87f1d2041939">UART_DMA_CHANNEL_23</a> = 1
 }</td></tr>
<tr class="memdesc:ga8fc237bc57dd45252e96589aa1a1e7f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART DMA channel configuration.  <a href="group___u_a_r_t.html#ga8fc237bc57dd45252e96589aa1a1e7f6">More...</a><br /></td></tr>
<tr class="separator:ga8fc237bc57dd45252e96589aa1a1e7f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga69d334701827bc97a2c2753b4597d5db"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#ga69d334701827bc97a2c2753b4597d5db">UART_OP_CFG</a> { <a class="el" href="group___u_a_r_t.html#gga69d334701827bc97a2c2753b4597d5dbae1aa531fac16efd1547d30ae661c7148">UART_OP_BLOCKING</a>, 
<a class="el" href="group___u_a_r_t.html#gga69d334701827bc97a2c2753b4597d5dbac6533ccaa1e3b0e2c6672cee6db4221e">UART_OP_INTR</a>, 
<a class="el" href="group___u_a_r_t.html#gga69d334701827bc97a2c2753b4597d5dba684d224393401c4a1ffb41166da828e6">UART_OP_DMA</a>
 }</td></tr>
<tr class="memdesc:ga69d334701827bc97a2c2753b4597d5db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mode of operation.  <a href="group___u_a_r_t.html#ga69d334701827bc97a2c2753b4597d5db">More...</a><br /></td></tr>
<tr class="separator:ga69d334701827bc97a2c2753b4597d5db"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga66d4c40771a984df9c75176d9673e291"><td class="memItemLeft" align="right" valign="top">__STATIC_FORCEINLINE uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#ga66d4c40771a984df9c75176d9673e291">uart_read_rbr</a> (<a class="el" href="structuart__t.html">uart_t</a> *uart_id)</td></tr>
<tr class="memdesc:ga66d4c40771a984df9c75176d9673e291"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a byte from Receive Buffer Register.  <a href="#ga66d4c40771a984df9c75176d9673e291">More...</a><br /></td></tr>
<tr class="separator:ga66d4c40771a984df9c75176d9673e291"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a22444176246b6a3ac548619978d63a"><td class="memItemLeft" align="right" valign="top">__STATIC_FORCEINLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#ga3a22444176246b6a3ac548619978d63a">uart_thr_setf</a> (<a class="el" href="structuart__t.html">uart_t</a> *uart_id, uint8_t data)</td></tr>
<tr class="memdesc:ga3a22444176246b6a3ac548619978d63a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write byte to Transmit Holding Register.  <a href="#ga3a22444176246b6a3ac548619978d63a">More...</a><br /></td></tr>
<tr class="separator:ga3a22444176246b6a3ac548619978d63a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c894d837702a10bb2d02b2e12ed5d4d"><td class="memItemLeft" align="right" valign="top">__STATIC_FORCEINLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#ga7c894d837702a10bb2d02b2e12ed5d4d">uart_dll_setf</a> (<a class="el" href="structuart__t.html">uart_t</a> *uart_id, uint8_t data)</td></tr>
<tr class="memdesc:ga7c894d837702a10bb2d02b2e12ed5d4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write byte to Divisor Latch (Low) Register.  <a href="#ga7c894d837702a10bb2d02b2e12ed5d4d">More...</a><br /></td></tr>
<tr class="separator:ga7c894d837702a10bb2d02b2e12ed5d4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae8afa777422c931fad2abcbb22a1c60d"><td class="memItemLeft" align="right" valign="top">__STATIC_FORCEINLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#gae8afa777422c931fad2abcbb22a1c60d">uart_dlh_setf</a> (<a class="el" href="structuart__t.html">uart_t</a> *uart_id, uint8_t data)</td></tr>
<tr class="memdesc:gae8afa777422c931fad2abcbb22a1c60d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write byte to Divisor Latch (High) Register.  <a href="#gae8afa777422c931fad2abcbb22a1c60d">More...</a><br /></td></tr>
<tr class="separator:gae8afa777422c931fad2abcbb22a1c60d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa4c3158f343f17b0097155962160e58c"><td class="memItemLeft" align="right" valign="top">__STATIC_FORCEINLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#gaa4c3158f343f17b0097155962160e58c">uart_rxdata_intr_setf</a> (<a class="el" href="structuart__t.html">uart_t</a> *uart_id, <a class="el" href="group___u_a_r_t.html#gabd218b2905cb2bad7f9d44912d63be3d">UART_BIT_CFG</a> erbfi_en)</td></tr>
<tr class="memdesc:gaa4c3158f343f17b0097155962160e58c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable/Disable Received Data Available Interrupt.  <a href="#gaa4c3158f343f17b0097155962160e58c">More...</a><br /></td></tr>
<tr class="separator:gaa4c3158f343f17b0097155962160e58c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3f0bed0a96e6768774085f5beb77c165"><td class="memItemLeft" align="right" valign="top">__STATIC_FORCEINLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#ga3f0bed0a96e6768774085f5beb77c165">uart_txdata_intr_setf</a> (<a class="el" href="structuart__t.html">uart_t</a> *uart_id, <a class="el" href="group___u_a_r_t.html#gabd218b2905cb2bad7f9d44912d63be3d">UART_BIT_CFG</a> etbei_en)</td></tr>
<tr class="memdesc:ga3f0bed0a96e6768774085f5beb77c165"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable/Disable Transmit Holding Register Empty Interrupt.  <a href="#ga3f0bed0a96e6768774085f5beb77c165">More...</a><br /></td></tr>
<tr class="separator:ga3f0bed0a96e6768774085f5beb77c165"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga48991de47b18c3f14a8ed62ac7b1036c"><td class="memItemLeft" align="right" valign="top">__STATIC_FORCEINLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#ga48991de47b18c3f14a8ed62ac7b1036c">uart_rls_intr_setf</a> (<a class="el" href="structuart__t.html">uart_t</a> *uart_id, <a class="el" href="group___u_a_r_t.html#gabd218b2905cb2bad7f9d44912d63be3d">UART_BIT_CFG</a> elsi_en)</td></tr>
<tr class="memdesc:ga48991de47b18c3f14a8ed62ac7b1036c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable/Disable Receiver Line Status Interrupt This is used to enable/disable the generation of Receiver Line Status Interrupt. This is the highest priority interrupt.  <a href="#ga48991de47b18c3f14a8ed62ac7b1036c">More...</a><br /></td></tr>
<tr class="separator:ga48991de47b18c3f14a8ed62ac7b1036c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga16212753fd4720260baace0b1ef82303"><td class="memItemLeft" align="right" valign="top">__STATIC_FORCEINLINE uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#ga16212753fd4720260baace0b1ef82303">uart_intr_config_getf</a> (<a class="el" href="structuart__t.html">uart_t</a> *uart_id)</td></tr>
<tr class="memdesc:ga16212753fd4720260baace0b1ef82303"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get interrupt configuration of UART.  <a href="#ga16212753fd4720260baace0b1ef82303">More...</a><br /></td></tr>
<tr class="separator:ga16212753fd4720260baace0b1ef82303"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga473fd4ca23ddca3314e26a6ea8895e68"><td class="memItemLeft" align="right" valign="top">__STATIC_FORCEINLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#ga473fd4ca23ddca3314e26a6ea8895e68">uart_thre_intr_setf</a> (<a class="el" href="structuart__t.html">uart_t</a> *uart_id, <a class="el" href="group___u_a_r_t.html#gabd218b2905cb2bad7f9d44912d63be3d">UART_BIT_CFG</a> ptime_en)</td></tr>
<tr class="memdesc:ga473fd4ca23ddca3314e26a6ea8895e68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable/Disable Programmable THRE Interrupt Mode.  <a href="#ga473fd4ca23ddca3314e26a6ea8895e68">More...</a><br /></td></tr>
<tr class="separator:ga473fd4ca23ddca3314e26a6ea8895e68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga62b972085a68612e3f2d303f4002ec19"><td class="memItemLeft" align="right" valign="top">__STATIC_FORCEINLINE uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#ga62b972085a68612e3f2d303f4002ec19">uart_intr_id_getf</a> (<a class="el" href="structuart__t.html">uart_t</a> *uart_id)</td></tr>
<tr class="memdesc:ga62b972085a68612e3f2d303f4002ec19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read Interrupt ID.  <a href="#ga62b972085a68612e3f2d303f4002ec19">More...</a><br /></td></tr>
<tr class="separator:ga62b972085a68612e3f2d303f4002ec19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2db7e6e6dc4f033750f80ca842f2ee50"><td class="memItemLeft" align="right" valign="top">__STATIC_FORCEINLINE uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#ga2db7e6e6dc4f033750f80ca842f2ee50">uart_fifo_enabled_getf</a> (<a class="el" href="structuart__t.html">uart_t</a> *uart_id)</td></tr>
<tr class="memdesc:ga2db7e6e6dc4f033750f80ca842f2ee50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicate whether the FIFO's are enabled or disabled.  <a href="#ga2db7e6e6dc4f033750f80ca842f2ee50">More...</a><br /></td></tr>
<tr class="separator:ga2db7e6e6dc4f033750f80ca842f2ee50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaafa9d1b39105316d9a4029bc7145c297"><td class="memItemLeft" align="right" valign="top">__STATIC_FORCEINLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#gaafa9d1b39105316d9a4029bc7145c297">uart_fifo_enable_setf</a> (<a class="el" href="structuart__t.html">uart_t</a> *uart_id, <a class="el" href="group___u_a_r_t.html#ga1d34e34ab58c383449603db0b5cd4e89">UART_FIFO_CFG</a> fifo_en)</td></tr>
<tr class="memdesc:gaafa9d1b39105316d9a4029bc7145c297"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable/Disable UART FIFOs.  <a href="#gaafa9d1b39105316d9a4029bc7145c297">More...</a><br /></td></tr>
<tr class="separator:gaafa9d1b39105316d9a4029bc7145c297"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3142f530691ced4991360d109b6bde6e"><td class="memItemLeft" align="right" valign="top">__STATIC_FORCEINLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#ga3142f530691ced4991360d109b6bde6e">uart_rxfifo_flush</a> (<a class="el" href="structuart__t.html">uart_t</a> *uart_id)</td></tr>
<tr class="memdesc:ga3142f530691ced4991360d109b6bde6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the control portion of the receive FIFO and treats the FIFO as empty.  <a href="#ga3142f530691ced4991360d109b6bde6e">More...</a><br /></td></tr>
<tr class="separator:ga3142f530691ced4991360d109b6bde6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga410d21f5c87e70f3e83911c0d3762d8c"><td class="memItemLeft" align="right" valign="top">__STATIC_FORCEINLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#ga410d21f5c87e70f3e83911c0d3762d8c">uart_txfifo_flush</a> (<a class="el" href="structuart__t.html">uart_t</a> *uart_id)</td></tr>
<tr class="memdesc:ga410d21f5c87e70f3e83911c0d3762d8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the control portion of the transmit FIFO and treats the FIFO as empty.  <a href="#ga410d21f5c87e70f3e83911c0d3762d8c">More...</a><br /></td></tr>
<tr class="separator:ga410d21f5c87e70f3e83911c0d3762d8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9514348aecbb204a0c3ee82bbe438e18"><td class="memItemLeft" align="right" valign="top">__STATIC_FORCEINLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#ga9514348aecbb204a0c3ee82bbe438e18">uart_fifo_txempty_trg_setf</a> (<a class="el" href="structuart__t.html">uart_t</a> *uart_id, <a class="el" href="group___u_a_r_t.html#ga10962da2c5916d3eb7890bab6ed7b3f4">UART_TX_FIFO_LEVEL</a> txempty_trigger)</td></tr>
<tr class="memdesc:ga9514348aecbb204a0c3ee82bbe438e18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the empty threshold level at which the THRE Interrupts will be generated when the mode is active.  <a href="#ga9514348aecbb204a0c3ee82bbe438e18">More...</a><br /></td></tr>
<tr class="separator:ga9514348aecbb204a0c3ee82bbe438e18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga52e9b28a5175419dddf165030fcfe7a4"><td class="memItemLeft" align="right" valign="top">__STATIC_FORCEINLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#ga52e9b28a5175419dddf165030fcfe7a4">uart_fifo_rcvr_trg_setf</a> (<a class="el" href="structuart__t.html">uart_t</a> *uart_id, <a class="el" href="group___u_a_r_t.html#ga56aaf477e65211c6e6858894d1590fd7">UART_RX_FIFO_LEVEL</a> rcvr_trigger)</td></tr>
<tr class="memdesc:ga52e9b28a5175419dddf165030fcfe7a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the trigger level in the receiver FIFO at which the Received Data Available Interrupt will be generated.  <a href="#ga52e9b28a5175419dddf165030fcfe7a4">More...</a><br /></td></tr>
<tr class="separator:ga52e9b28a5175419dddf165030fcfe7a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab3acbcedc0f268b7ef1bacc27accfba4"><td class="memItemLeft" align="right" valign="top">__STATIC_FORCEINLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#gab3acbcedc0f268b7ef1bacc27accfba4">uart_lcr_setf</a> (<a class="el" href="structuart__t.html">uart_t</a> *uart_id, uint16_t lcr_val)</td></tr>
<tr class="memdesc:gab3acbcedc0f268b7ef1bacc27accfba4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a value to LCR.  <a href="#gab3acbcedc0f268b7ef1bacc27accfba4">More...</a><br /></td></tr>
<tr class="separator:gab3acbcedc0f268b7ef1bacc27accfba4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8d1931bdc580fee277b84d682c21e9d8"><td class="memItemLeft" align="right" valign="top">__STATIC_FORCEINLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#ga8d1931bdc580fee277b84d682c21e9d8">uart_dlab_setf</a> (<a class="el" href="structuart__t.html">uart_t</a> *uart_id, <a class="el" href="group___u_a_r_t.html#gabd218b2905cb2bad7f9d44912d63be3d">UART_BIT_CFG</a> dlab)</td></tr>
<tr class="memdesc:ga8d1931bdc580fee277b84d682c21e9d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable/Disable Divisor Latch Access Bit.  <a href="#ga8d1931bdc580fee277b84d682c21e9d8">More...</a><br /></td></tr>
<tr class="separator:ga8d1931bdc580fee277b84d682c21e9d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb5c5e15903d882ec93b832b064fe318"><td class="memItemLeft" align="right" valign="top">__STATIC_FORCEINLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#gacb5c5e15903d882ec93b832b064fe318">uart_bc_setf</a> (<a class="el" href="structuart__t.html">uart_t</a> *uart_id, <a class="el" href="group___u_a_r_t.html#gabd218b2905cb2bad7f9d44912d63be3d">UART_BIT_CFG</a> bc)</td></tr>
<tr class="memdesc:gacb5c5e15903d882ec93b832b064fe318"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable/Disable Break Control Bit.  <a href="#gacb5c5e15903d882ec93b832b064fe318">More...</a><br /></td></tr>
<tr class="separator:gacb5c5e15903d882ec93b832b064fe318"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ae77b84e60936544693b4e87b604ddd"><td class="memItemLeft" align="right" valign="top">__STATIC_FORCEINLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#ga1ae77b84e60936544693b4e87b604ddd">uart_parity_setf</a> (<a class="el" href="structuart__t.html">uart_t</a> *uart_id, <a class="el" href="group___u_a_r_t.html#ga24fd4dba815fc40fbd8e8c37dbf87c7a">UART_PARITY</a> parity)</td></tr>
<tr class="memdesc:ga1ae77b84e60936544693b4e87b604ddd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set Parity.  <a href="#ga1ae77b84e60936544693b4e87b604ddd">More...</a><br /></td></tr>
<tr class="separator:ga1ae77b84e60936544693b4e87b604ddd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab4049d007b799bc0f3569b86d5dcd8bb"><td class="memItemLeft" align="right" valign="top">__STATIC_FORCEINLINE uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#gab4049d007b799bc0f3569b86d5dcd8bb">uart_parity_getf</a> (<a class="el" href="structuart__t.html">uart_t</a> *uart_id)</td></tr>
<tr class="memdesc:gab4049d007b799bc0f3569b86d5dcd8bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get Parity configuration of UART.  <a href="#gab4049d007b799bc0f3569b86d5dcd8bb">More...</a><br /></td></tr>
<tr class="separator:gab4049d007b799bc0f3569b86d5dcd8bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga501e17f226a93522e44ddec3b186d700"><td class="memItemLeft" align="right" valign="top">__STATIC_FORCEINLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#ga501e17f226a93522e44ddec3b186d700">uart_stop_bits_setf</a> (<a class="el" href="structuart__t.html">uart_t</a> *uart_id, <a class="el" href="group___u_a_r_t.html#gacbd51ac613ec824eeb73a5b6bf743ca6">UART_STOPBITS</a> stop_bits)</td></tr>
<tr class="memdesc:ga501e17f226a93522e44ddec3b186d700"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set number of stop bits.  <a href="#ga501e17f226a93522e44ddec3b186d700">More...</a><br /></td></tr>
<tr class="separator:ga501e17f226a93522e44ddec3b186d700"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0bfc37843697051566ae688fb2adffe8"><td class="memItemLeft" align="right" valign="top">__STATIC_FORCEINLINE uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#ga0bfc37843697051566ae688fb2adffe8">uart_stop_bits_getf</a> (<a class="el" href="structuart__t.html">uart_t</a> *uart_id)</td></tr>
<tr class="memdesc:ga0bfc37843697051566ae688fb2adffe8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get stop bits configuration of UART.  <a href="#ga0bfc37843697051566ae688fb2adffe8">More...</a><br /></td></tr>
<tr class="separator:ga0bfc37843697051566ae688fb2adffe8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ec3a051e774d36fcc7bf29f330644f2"><td class="memItemLeft" align="right" valign="top">__STATIC_FORCEINLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#ga9ec3a051e774d36fcc7bf29f330644f2">uart_dls_setf</a> (<a class="el" href="structuart__t.html">uart_t</a> *uart_id, <a class="el" href="group___u_a_r_t.html#ga24f73385af2d9c46d405402760a30766">UART_DATABITS</a> dls)</td></tr>
<tr class="memdesc:ga9ec3a051e774d36fcc7bf29f330644f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set Data Length Select.  <a href="#ga9ec3a051e774d36fcc7bf29f330644f2">More...</a><br /></td></tr>
<tr class="separator:ga9ec3a051e774d36fcc7bf29f330644f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacc71455c02d9fb7fef33691fac3938c1"><td class="memItemLeft" align="right" valign="top">__STATIC_FORCEINLINE uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#gacc71455c02d9fb7fef33691fac3938c1">uart_dls_getf</a> (<a class="el" href="structuart__t.html">uart_t</a> *uart_id)</td></tr>
<tr class="memdesc:gacc71455c02d9fb7fef33691fac3938c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get Data Length Select configuration of UART.  <a href="#gacc71455c02d9fb7fef33691fac3938c1">More...</a><br /></td></tr>
<tr class="separator:gacc71455c02d9fb7fef33691fac3938c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga24764f0482c63b02067bf3d8e24f4a00"><td class="memItemLeft" align="right" valign="top">__STATIC_FORCEINLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#ga24764f0482c63b02067bf3d8e24f4a00">uart_sire_setf</a> (<a class="el" href="structuart__t.html">uart_t</a> *uart_id, <a class="el" href="group___u_a_r_t.html#gabd218b2905cb2bad7f9d44912d63be3d">UART_BIT_CFG</a> sire)</td></tr>
<tr class="memdesc:ga24764f0482c63b02067bf3d8e24f4a00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable/Disable SIR Mode.  <a href="#ga24764f0482c63b02067bf3d8e24f4a00">More...</a><br /></td></tr>
<tr class="separator:ga24764f0482c63b02067bf3d8e24f4a00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaad24d9f5043b06fb70553477fd2527b0"><td class="memItemLeft" align="right" valign="top">__STATIC_FORCEINLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#gaad24d9f5043b06fb70553477fd2527b0">uart_afce_setf</a> (<a class="el" href="structuart__t.html">uart_t</a> *uart_id, <a class="el" href="group___u_a_r_t.html#ga2a2e6711c13f801499299cf273a5e4e6">UART_AFCE_CFG</a> afce)</td></tr>
<tr class="memdesc:gaad24d9f5043b06fb70553477fd2527b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable/Disable Auto Flow Control.  <a href="#gaad24d9f5043b06fb70553477fd2527b0">More...</a><br /></td></tr>
<tr class="separator:gaad24d9f5043b06fb70553477fd2527b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac54223e272335cb7f84a7b60663bbe18"><td class="memItemLeft" align="right" valign="top">__STATIC_FORCEINLINE uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#gac54223e272335cb7f84a7b60663bbe18">uart_afce_getf</a> (<a class="el" href="structuart__t.html">uart_t</a> *uart_id)</td></tr>
<tr class="memdesc:gac54223e272335cb7f84a7b60663bbe18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get Auto Flow Control configuration of UART.  <a href="#gac54223e272335cb7f84a7b60663bbe18">More...</a><br /></td></tr>
<tr class="separator:gac54223e272335cb7f84a7b60663bbe18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaac120ac24dd850b520e7f3a07321b02f"><td class="memItemLeft" align="right" valign="top">__STATIC_FORCEINLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#gaac120ac24dd850b520e7f3a07321b02f">uart_rtsn_setf</a> (<a class="el" href="structuart__t.html">uart_t</a> *uart_id, <a class="el" href="group___u_a_r_t.html#ga2a2e6711c13f801499299cf273a5e4e6">UART_AFCE_CFG</a> rts_n)</td></tr>
<tr class="memdesc:gaac120ac24dd850b520e7f3a07321b02f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable/Disable Request to Send.  <a href="#gaac120ac24dd850b520e7f3a07321b02f">More...</a><br /></td></tr>
<tr class="separator:gaac120ac24dd850b520e7f3a07321b02f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab498496ef1d433538067451ff4ca9051"><td class="memItemLeft" align="right" valign="top">__STATIC_FORCEINLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#gab498496ef1d433538067451ff4ca9051">uart_loopback_setf</a> (<a class="el" href="structuart__t.html">uart_t</a> *uart_id, <a class="el" href="group___u_a_r_t.html#gabd218b2905cb2bad7f9d44912d63be3d">UART_BIT_CFG</a> lb_en)</td></tr>
<tr class="memdesc:gab498496ef1d433538067451ff4ca9051"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable/Disable LoopBack.  <a href="#gab498496ef1d433538067451ff4ca9051">More...</a><br /></td></tr>
<tr class="separator:gab498496ef1d433538067451ff4ca9051"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada0a473feaf9b949d0ba442a652b6de3"><td class="memItemLeft" align="right" valign="top">__STATIC_FORCEINLINE uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#gada0a473feaf9b949d0ba442a652b6de3">uart_tx_empty_getf</a> (<a class="el" href="structuart__t.html">uart_t</a> *uart_id)</td></tr>
<tr class="memdesc:gada0a473feaf9b949d0ba442a652b6de3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transmitter Empty bit.  <a href="#gada0a473feaf9b949d0ba442a652b6de3">More...</a><br /></td></tr>
<tr class="separator:gada0a473feaf9b949d0ba442a652b6de3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2755364dfcc21b7aa67c0a9232e0fe0a"><td class="memItemLeft" align="right" valign="top">__STATIC_FORCEINLINE uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#ga2755364dfcc21b7aa67c0a9232e0fe0a">uart_thr_empty_getf</a> (<a class="el" href="structuart__t.html">uart_t</a> *uart_id)</td></tr>
<tr class="memdesc:ga2755364dfcc21b7aa67c0a9232e0fe0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transmit Holding Register Empty bit.  <a href="#ga2755364dfcc21b7aa67c0a9232e0fe0a">More...</a><br /></td></tr>
<tr class="separator:ga2755364dfcc21b7aa67c0a9232e0fe0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga00bcdc5b999362937e4424b3a3cf4259"><td class="memItemLeft" align="right" valign="top">__STATIC_FORCEINLINE uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#ga00bcdc5b999362937e4424b3a3cf4259">uart_data_ready_getf</a> (<a class="el" href="structuart__t.html">uart_t</a> *uart_id)</td></tr>
<tr class="memdesc:ga00bcdc5b999362937e4424b3a3cf4259"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data Ready bit.  <a href="#ga00bcdc5b999362937e4424b3a3cf4259">More...</a><br /></td></tr>
<tr class="separator:ga00bcdc5b999362937e4424b3a3cf4259"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf849ba8b9afad38bf677d8141dd9f2a0"><td class="memItemLeft" align="right" valign="top">__STATIC_FORCEINLINE uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#gaf849ba8b9afad38bf677d8141dd9f2a0">uart_rls_error_getf</a> (<a class="el" href="structuart__t.html">uart_t</a> *uart_id)</td></tr>
<tr class="memdesc:gaf849ba8b9afad38bf677d8141dd9f2a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get RLS errors.  <a href="#gaf849ba8b9afad38bf677d8141dd9f2a0">More...</a><br /></td></tr>
<tr class="separator:gaf849ba8b9afad38bf677d8141dd9f2a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4067366f6aff74ffc5bdcd1ef2da1c99"><td class="memItemLeft" align="right" valign="top">__STATIC_FORCEINLINE uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#ga4067366f6aff74ffc5bdcd1ef2da1c99">uart_cts_getf</a> (<a class="el" href="structuart__t.html">uart_t</a> *uart_id)</td></tr>
<tr class="memdesc:ga4067366f6aff74ffc5bdcd1ef2da1c99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear to Send.  <a href="#ga4067366f6aff74ffc5bdcd1ef2da1c99">More...</a><br /></td></tr>
<tr class="separator:ga4067366f6aff74ffc5bdcd1ef2da1c99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa46e97716f060125d09c34c75dc7115d"><td class="memItemLeft" align="right" valign="top">__STATIC_FORCEINLINE uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#gaa46e97716f060125d09c34c75dc7115d">uart_dcts_getf</a> (<a class="el" href="structuart__t.html">uart_t</a> *uart_id)</td></tr>
<tr class="memdesc:gaa46e97716f060125d09c34c75dc7115d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delta Clear to Send.  <a href="#gaa46e97716f060125d09c34c75dc7115d">More...</a><br /></td></tr>
<tr class="separator:gaa46e97716f060125d09c34c75dc7115d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1733e3fc1c5add13047e239e20bd666e"><td class="memItemLeft" align="right" valign="top">__STATIC_FORCEINLINE uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#ga1733e3fc1c5add13047e239e20bd666e">uart_scr_reg_getf</a> (<a class="el" href="structuart__t.html">uart_t</a> *uart_id)</td></tr>
<tr class="memdesc:ga1733e3fc1c5add13047e239e20bd666e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This register is for programmers to use as a temporary storage space.  <a href="#ga1733e3fc1c5add13047e239e20bd666e">More...</a><br /></td></tr>
<tr class="separator:ga1733e3fc1c5add13047e239e20bd666e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a4a5208838782dc2697814a9aabfe1b"><td class="memItemLeft" align="right" valign="top">__STATIC_FORCEINLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#ga5a4a5208838782dc2697814a9aabfe1b">uart_scr_reg_setf</a> (<a class="el" href="structuart__t.html">uart_t</a> *uart_id, uint8_t data)</td></tr>
<tr class="memdesc:ga5a4a5208838782dc2697814a9aabfe1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This register is for programmers to use as a temporary storage space.  <a href="#ga5a4a5208838782dc2697814a9aabfe1b">More...</a><br /></td></tr>
<tr class="separator:ga5a4a5208838782dc2697814a9aabfe1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac605b798d0411d9246c5fe9b93da4c72"><td class="memItemLeft" align="right" valign="top">__STATIC_FORCEINLINE uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#gac605b798d0411d9246c5fe9b93da4c72">uart_rxfifo_is_full_getf</a> (<a class="el" href="structuart__t.html">uart_t</a> *uart_id)</td></tr>
<tr class="memdesc:gac605b798d0411d9246c5fe9b93da4c72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receive FIFO Full.  <a href="#gac605b798d0411d9246c5fe9b93da4c72">More...</a><br /></td></tr>
<tr class="separator:gac605b798d0411d9246c5fe9b93da4c72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3fc4e229be420bc1edca175df1b8e6dc"><td class="memItemLeft" align="right" valign="top">__STATIC_FORCEINLINE uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#ga3fc4e229be420bc1edca175df1b8e6dc">uart_rxfifo_not_empty_getf</a> (<a class="el" href="structuart__t.html">uart_t</a> *uart_id)</td></tr>
<tr class="memdesc:ga3fc4e229be420bc1edca175df1b8e6dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receive FIFO Not Empty.  <a href="#ga3fc4e229be420bc1edca175df1b8e6dc">More...</a><br /></td></tr>
<tr class="separator:ga3fc4e229be420bc1edca175df1b8e6dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac1928af7c7dcbec8d66cf8fbc82a8b23"><td class="memItemLeft" align="right" valign="top">__STATIC_FORCEINLINE uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#gac1928af7c7dcbec8d66cf8fbc82a8b23">uart_txfifo_is_empty_getf</a> (<a class="el" href="structuart__t.html">uart_t</a> *uart_id)</td></tr>
<tr class="memdesc:gac1928af7c7dcbec8d66cf8fbc82a8b23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transmit FIFO Empty.  <a href="#gac1928af7c7dcbec8d66cf8fbc82a8b23">More...</a><br /></td></tr>
<tr class="separator:gac1928af7c7dcbec8d66cf8fbc82a8b23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd8c121219523de286d063023af76f6d"><td class="memItemLeft" align="right" valign="top">__STATIC_FORCEINLINE uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#gafd8c121219523de286d063023af76f6d">uart_txfifo_not_full_getf</a> (<a class="el" href="structuart__t.html">uart_t</a> *uart_id)</td></tr>
<tr class="memdesc:gafd8c121219523de286d063023af76f6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transmit FIFO Not Full.  <a href="#gafd8c121219523de286d063023af76f6d">More...</a><br /></td></tr>
<tr class="separator:gafd8c121219523de286d063023af76f6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7b307ae2dd545073f568af8d7970438a"><td class="memItemLeft" align="right" valign="top">__STATIC_FORCEINLINE uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#ga7b307ae2dd545073f568af8d7970438a">uart_is_busy_getf</a> (<a class="el" href="structuart__t.html">uart_t</a> *uart_id)</td></tr>
<tr class="memdesc:ga7b307ae2dd545073f568af8d7970438a"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART Busy.  <a href="#ga7b307ae2dd545073f568af8d7970438a">More...</a><br /></td></tr>
<tr class="separator:ga7b307ae2dd545073f568af8d7970438a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1107af4317dfb647fdf8c733e42810db"><td class="memItemLeft" align="right" valign="top">__STATIC_FORCEINLINE uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#ga1107af4317dfb647fdf8c733e42810db">uart_txfifo_level_getf</a> (<a class="el" href="structuart__t.html">uart_t</a> *uart_id)</td></tr>
<tr class="memdesc:ga1107af4317dfb647fdf8c733e42810db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transmit FIFO Level.  <a href="#ga1107af4317dfb647fdf8c733e42810db">More...</a><br /></td></tr>
<tr class="separator:ga1107af4317dfb647fdf8c733e42810db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga90ca512ff8ff50986758f24ec36a8712"><td class="memItemLeft" align="right" valign="top">__STATIC_FORCEINLINE uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#ga90ca512ff8ff50986758f24ec36a8712">uart_rxfifo_level_getf</a> (<a class="el" href="structuart__t.html">uart_t</a> *uart_id)</td></tr>
<tr class="memdesc:ga90ca512ff8ff50986758f24ec36a8712"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receive FIFO Level.  <a href="#ga90ca512ff8ff50986758f24ec36a8712">More...</a><br /></td></tr>
<tr class="separator:ga90ca512ff8ff50986758f24ec36a8712"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac1e12e30412b38e43230d111b2e10f20"><td class="memItemLeft" align="right" valign="top">__STATIC_FORCEINLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#gac1e12e30412b38e43230d111b2e10f20">uart_txfifo_flush_shd</a> (<a class="el" href="structuart__t.html">uart_t</a> *uart_id)</td></tr>
<tr class="memdesc:gac1e12e30412b38e43230d111b2e10f20"><td class="mdescLeft">&#160;</td><td class="mdescRight">XMIT FIFO Reset.  <a href="#gac1e12e30412b38e43230d111b2e10f20">More...</a><br /></td></tr>
<tr class="separator:gac1e12e30412b38e43230d111b2e10f20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab55514b096939cb90732f0cd1b00abf"><td class="memItemLeft" align="right" valign="top">__STATIC_FORCEINLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#gaab55514b096939cb90732f0cd1b00abf">uart_rxfifo_flush_shd</a> (<a class="el" href="structuart__t.html">uart_t</a> *uart_id)</td></tr>
<tr class="memdesc:gaab55514b096939cb90732f0cd1b00abf"><td class="mdescLeft">&#160;</td><td class="mdescRight">RCVR FIFO Reset.  <a href="#gaab55514b096939cb90732f0cd1b00abf">More...</a><br /></td></tr>
<tr class="separator:gaab55514b096939cb90732f0cd1b00abf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabdf07dd559171e4e2bca3a1d02f365c7"><td class="memItemLeft" align="right" valign="top">__STATIC_FORCEINLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#gabdf07dd559171e4e2bca3a1d02f365c7">uart_rst_shd_setf</a> (<a class="el" href="structuart__t.html">uart_t</a> *uart_id)</td></tr>
<tr class="memdesc:gabdf07dd559171e4e2bca3a1d02f365c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART Reset.  <a href="#gabdf07dd559171e4e2bca3a1d02f365c7">More...</a><br /></td></tr>
<tr class="separator:gabdf07dd559171e4e2bca3a1d02f365c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae815720f3e17a853544b927dfe7338b0"><td class="memItemLeft" align="right" valign="top">__STATIC_FORCEINLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#gae815720f3e17a853544b927dfe7338b0">uart_rts_shd_setf</a> (<a class="el" href="structuart__t.html">uart_t</a> *uart_id, <a class="el" href="group___u_a_r_t.html#gabd218b2905cb2bad7f9d44912d63be3d">UART_BIT_CFG</a> uart_rts)</td></tr>
<tr class="memdesc:gae815720f3e17a853544b927dfe7338b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shadow Request to Send.  <a href="#gae815720f3e17a853544b927dfe7338b0">More...</a><br /></td></tr>
<tr class="separator:gae815720f3e17a853544b927dfe7338b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga182d115a153688ad6fb585f5dea1dabe"><td class="memItemLeft" align="right" valign="top">__STATIC_FORCEINLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#ga182d115a153688ad6fb585f5dea1dabe">uart_break_ctrl_shd_setf</a> (<a class="el" href="structuart__t.html">uart_t</a> *uart_id, <a class="el" href="group___u_a_r_t.html#gabd218b2905cb2bad7f9d44912d63be3d">UART_BIT_CFG</a> uart_break_ctrl)</td></tr>
<tr class="memdesc:ga182d115a153688ad6fb585f5dea1dabe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shadow Break Control Bit.  <a href="#ga182d115a153688ad6fb585f5dea1dabe">More...</a><br /></td></tr>
<tr class="separator:ga182d115a153688ad6fb585f5dea1dabe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5cec7693c0bae9e14939aabf6751ac1d"><td class="memItemLeft" align="right" valign="top">__STATIC_FORCEINLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#ga5cec7693c0bae9e14939aabf6751ac1d">uart_dma_mode_shd_setf</a> (<a class="el" href="structuart__t.html">uart_t</a> *uart_id, uint8_t dma_mode)</td></tr>
<tr class="memdesc:ga5cec7693c0bae9e14939aabf6751ac1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shadow DMA Mode.  <a href="#ga5cec7693c0bae9e14939aabf6751ac1d">More...</a><br /></td></tr>
<tr class="separator:ga5cec7693c0bae9e14939aabf6751ac1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2196e40beecb150a770e6bc4b8cfca80"><td class="memItemLeft" align="right" valign="top">__STATIC_FORCEINLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#ga2196e40beecb150a770e6bc4b8cfca80">uart_fifo_enable_shd_setf</a> (<a class="el" href="structuart__t.html">uart_t</a> *uart_id, <a class="el" href="group___u_a_r_t.html#ga1d34e34ab58c383449603db0b5cd4e89">UART_FIFO_CFG</a> fifo_en)</td></tr>
<tr class="memdesc:ga2196e40beecb150a770e6bc4b8cfca80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shadow FIFO Enable.  <a href="#ga2196e40beecb150a770e6bc4b8cfca80">More...</a><br /></td></tr>
<tr class="separator:ga2196e40beecb150a770e6bc4b8cfca80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad5b542b18bc052f2c788d46bf606d241"><td class="memItemLeft" align="right" valign="top">__STATIC_FORCEINLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#gad5b542b18bc052f2c788d46bf606d241">uart_fifo_rcvr_trg_shd_setf</a> (<a class="el" href="structuart__t.html">uart_t</a> *uart_id, <a class="el" href="group___u_a_r_t.html#ga56aaf477e65211c6e6858894d1590fd7">UART_RX_FIFO_LEVEL</a> rcvr_trigger)</td></tr>
<tr class="memdesc:gad5b542b18bc052f2c788d46bf606d241"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shadow RCVR Trigger.  <a href="#gad5b542b18bc052f2c788d46bf606d241">More...</a><br /></td></tr>
<tr class="separator:gad5b542b18bc052f2c788d46bf606d241"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7b469dba7cf7febba432100782853bfe"><td class="memItemLeft" align="right" valign="top">__STATIC_FORCEINLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#ga7b469dba7cf7febba432100782853bfe">uart_fifo_txempty_trg_shd_setf</a> (<a class="el" href="structuart__t.html">uart_t</a> *uart_id, <a class="el" href="group___u_a_r_t.html#ga10962da2c5916d3eb7890bab6ed7b3f4">UART_TX_FIFO_LEVEL</a> txempty_trigger)</td></tr>
<tr class="memdesc:ga7b469dba7cf7febba432100782853bfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shadow TX Empty Trigger.  <a href="#ga7b469dba7cf7febba432100782853bfe">More...</a><br /></td></tr>
<tr class="separator:ga7b469dba7cf7febba432100782853bfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaabb0ffafed4c9aaefd185780e015428b"><td class="memItemLeft" align="right" valign="top">__STATIC_FORCEINLINE uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#gaabb0ffafed4c9aaefd185780e015428b">uart_halt_getf</a> (<a class="el" href="structuart__t.html">uart_t</a> *uart_id)</td></tr>
<tr class="memdesc:gaabb0ffafed4c9aaefd185780e015428b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read Halt Transmit configuration.  <a href="#gaabb0ffafed4c9aaefd185780e015428b">More...</a><br /></td></tr>
<tr class="separator:gaabb0ffafed4c9aaefd185780e015428b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga00659951dae871ec6787ef182318d9f6"><td class="memItemLeft" align="right" valign="top">__STATIC_FORCEINLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#ga00659951dae871ec6787ef182318d9f6">uart_halt_setf</a> (<a class="el" href="structuart__t.html">uart_t</a> *uart_id, <a class="el" href="group___u_a_r_t.html#gabd218b2905cb2bad7f9d44912d63be3d">UART_BIT_CFG</a> halt_en)</td></tr>
<tr class="memdesc:ga00659951dae871ec6787ef182318d9f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Halt Transmit.  <a href="#ga00659951dae871ec6787ef182318d9f6">More...</a><br /></td></tr>
<tr class="separator:ga00659951dae871ec6787ef182318d9f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga331387733c05fe11c9c6523469908f5d"><td class="memItemLeft" align="right" valign="top">__STATIC_FORCEINLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#ga331387733c05fe11c9c6523469908f5d">uart_dmasa_setf</a> (<a class="el" href="structuart__t.html">uart_t</a> *uart_id, <a class="el" href="group___u_a_r_t.html#gabd218b2905cb2bad7f9d44912d63be3d">UART_BIT_CFG</a> dmasa_en)</td></tr>
<tr class="memdesc:ga331387733c05fe11c9c6523469908f5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This register is use to perform DMA software acknowledge if a transfer needs to be terminated due to an error condition.  <a href="#ga331387733c05fe11c9c6523469908f5d">More...</a><br /></td></tr>
<tr class="separator:ga331387733c05fe11c9c6523469908f5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac35f7ef0e0421cf2feb09d238d6a4919"><td class="memItemLeft" align="right" valign="top">__STATIC_FORCEINLINE uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#gac35f7ef0e0421cf2feb09d238d6a4919">uart_dlf_getf</a> (<a class="el" href="structuart__t.html">uart_t</a> *uart_id)</td></tr>
<tr class="memdesc:gac35f7ef0e0421cf2feb09d238d6a4919"><td class="mdescLeft">&#160;</td><td class="mdescRight">The fractional value is added to integer value set by DLH, DLL.  <a href="#gac35f7ef0e0421cf2feb09d238d6a4919">More...</a><br /></td></tr>
<tr class="separator:gac35f7ef0e0421cf2feb09d238d6a4919"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6dc9f74e185662f3a3be1cc7ef1ea31c"><td class="memItemLeft" align="right" valign="top">__STATIC_FORCEINLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#ga6dc9f74e185662f3a3be1cc7ef1ea31c">uart_dlf_setf</a> (<a class="el" href="structuart__t.html">uart_t</a> *uart_id, uint8_t dlf)</td></tr>
<tr class="memdesc:ga6dc9f74e185662f3a3be1cc7ef1ea31c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The fractional value is added to integer value set by DLH, DLL.  <a href="#ga6dc9f74e185662f3a3be1cc7ef1ea31c">More...</a><br /></td></tr>
<tr class="separator:ga6dc9f74e185662f3a3be1cc7ef1ea31c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafbe95da911950161c8ff2669875d19d7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#gafbe95da911950161c8ff2669875d19d7">uart_enable</a> (<a class="el" href="structuart__t.html">uart_t</a> *uart_id)</td></tr>
<tr class="memdesc:gafbe95da911950161c8ff2669875d19d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable clock for UART peripheral.  <a href="#gafbe95da911950161c8ff2669875d19d7">More...</a><br /></td></tr>
<tr class="separator:gafbe95da911950161c8ff2669875d19d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga62367146f0b04d10a13cc71111955504"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#ga62367146f0b04d10a13cc71111955504">uart_disable</a> (<a class="el" href="structuart__t.html">uart_t</a> *uart_id)</td></tr>
<tr class="memdesc:ga62367146f0b04d10a13cc71111955504"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset UART and disable clock for UART peripheral.  <a href="#ga62367146f0b04d10a13cc71111955504">More...</a><br /></td></tr>
<tr class="separator:ga62367146f0b04d10a13cc71111955504"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac6557bb02351d0e112dcf221e9946d3b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#gac6557bb02351d0e112dcf221e9946d3b">uart_baudrate_setf</a> (<a class="el" href="structuart__t.html">uart_t</a> *uart_id, <a class="el" href="group___u_a_r_t.html#ga2ebef9ab11e56d9d914a270f8a895034">UART_BAUDRATE</a> baud_rate)</td></tr>
<tr class="memdesc:gac6557bb02351d0e112dcf221e9946d3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set Baud rate.  <a href="#gac6557bb02351d0e112dcf221e9946d3b">More...</a><br /></td></tr>
<tr class="separator:gac6557bb02351d0e112dcf221e9946d3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f742f5c61daeb943353cc4be7775f9d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#ga0f742f5c61daeb943353cc4be7775f9d">uart_register_tx_cb</a> (<a class="el" href="structuart__t.html">uart_t</a> *uart_id, <a class="el" href="group___u_a_r_t.html#ga587d4439909898b9ae38e9aca950ae02">uart_cb_t</a> cb)</td></tr>
<tr class="memdesc:ga0f742f5c61daeb943353cc4be7775f9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register UART transmit callback (on-the-fly). Callback to return in interrupt/DMA-driven transmitting operations.  <a href="#ga0f742f5c61daeb943353cc4be7775f9d">More...</a><br /></td></tr>
<tr class="separator:ga0f742f5c61daeb943353cc4be7775f9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga57fc914e051d99d433a0e8b75b8094c1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#ga57fc914e051d99d433a0e8b75b8094c1">uart_register_rx_cb</a> (<a class="el" href="structuart__t.html">uart_t</a> *uart_id, <a class="el" href="group___u_a_r_t.html#ga587d4439909898b9ae38e9aca950ae02">uart_cb_t</a> cb)</td></tr>
<tr class="memdesc:ga57fc914e051d99d433a0e8b75b8094c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register UART receive callback (on-the-fly). Callback to return in interrupt/DMA-driven receiving operations.  <a href="#ga57fc914e051d99d433a0e8b75b8094c1">More...</a><br /></td></tr>
<tr class="separator:ga57fc914e051d99d433a0e8b75b8094c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0bc3887b353b90ca43f5860787bbc489"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#ga0bc3887b353b90ca43f5860787bbc489">uart_register_err_cb</a> (<a class="el" href="structuart__t.html">uart_t</a> *uart_id, <a class="el" href="group___u_a_r_t.html#ga54e57286e0cd5aa49304eff5ed78156c">uart_err_cb_t</a> cb)</td></tr>
<tr class="memdesc:ga0bc3887b353b90ca43f5860787bbc489"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register UART ERROR/STATYS callback (on-the-fly).  <a href="#ga0bc3887b353b90ca43f5860787bbc489">More...</a><br /></td></tr>
<tr class="separator:ga0bc3887b353b90ca43f5860787bbc489"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabdce908b80fca62f2b394bedc92e08a5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#gabdce908b80fca62f2b394bedc92e08a5">uart_initialize</a> (<a class="el" href="structuart__t.html">uart_t</a> *uart_id, const <a class="el" href="structuart__cfg__t.html">uart_cfg_t</a> *uart_cfg)</td></tr>
<tr class="memdesc:gabdce908b80fca62f2b394bedc92e08a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize UART peripheral with custom settings.  <a href="#gabdce908b80fca62f2b394bedc92e08a5">More...</a><br /></td></tr>
<tr class="separator:gabdce908b80fca62f2b394bedc92e08a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9038578a8bf8750edaa312278d5c8162"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#ga9038578a8bf8750edaa312278d5c8162">uart_write_byte</a> (<a class="el" href="structuart__t.html">uart_t</a> *uart_id, uint8_t data)</td></tr>
<tr class="memdesc:ga9038578a8bf8750edaa312278d5c8162"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write one byte to UART.  <a href="#ga9038578a8bf8750edaa312278d5c8162">More...</a><br /></td></tr>
<tr class="separator:ga9038578a8bf8750edaa312278d5c8162"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac852018305c0a03156ee9c7d20eb592d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#gac852018305c0a03156ee9c7d20eb592d">uart_write_buffer</a> (<a class="el" href="structuart__t.html">uart_t</a> *uart_id, const uint8_t *data, uint16_t len)</td></tr>
<tr class="memdesc:gac852018305c0a03156ee9c7d20eb592d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a number of bytes to UART.  <a href="#gac852018305c0a03156ee9c7d20eb592d">More...</a><br /></td></tr>
<tr class="separator:gac852018305c0a03156ee9c7d20eb592d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7bab515ae0edd81cca4095ca2a73e7d8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#ga7bab515ae0edd81cca4095ca2a73e7d8">uart_send</a> (<a class="el" href="structuart__t.html">uart_t</a> *uart_id, const uint8_t *data, uint16_t len, <a class="el" href="group___u_a_r_t.html#ga69d334701827bc97a2c2753b4597d5db">UART_OP_CFG</a> op)</td></tr>
<tr class="memdesc:ga7bab515ae0edd81cca4095ca2a73e7d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start sending data to UART transmitter.  <a href="#ga7bab515ae0edd81cca4095ca2a73e7d8">More...</a><br /></td></tr>
<tr class="separator:ga7bab515ae0edd81cca4095ca2a73e7d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9473f9474d6613c9a187259008075b2e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#ga9473f9474d6613c9a187259008075b2e">uart_wait_tx_finish</a> (<a class="el" href="structuart__t.html">uart_t</a> *uart_id)</td></tr>
<tr class="memdesc:ga9473f9474d6613c9a187259008075b2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait until UART has finished all transfers.  <a href="#ga9473f9474d6613c9a187259008075b2e">More...</a><br /></td></tr>
<tr class="separator:ga9473f9474d6613c9a187259008075b2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab665c813197eb77e836d27a314db37a5"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#gab665c813197eb77e836d27a314db37a5">uart_read_byte</a> (<a class="el" href="structuart__t.html">uart_t</a> *uart_id)</td></tr>
<tr class="memdesc:gab665c813197eb77e836d27a314db37a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read one byte from UART. If FIFO is empty, it polls until received data are available.  <a href="#gab665c813197eb77e836d27a314db37a5">More...</a><br /></td></tr>
<tr class="separator:gab665c813197eb77e836d27a314db37a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga53ee37e22077f15f4cd7687bec548bcb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#ga53ee37e22077f15f4cd7687bec548bcb">uart_read_buffer</a> (<a class="el" href="structuart__t.html">uart_t</a> *uart_id, uint8_t *data, uint16_t len)</td></tr>
<tr class="memdesc:ga53ee37e22077f15f4cd7687bec548bcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read number of bytes from UART.  <a href="#ga53ee37e22077f15f4cd7687bec548bcb">More...</a><br /></td></tr>
<tr class="separator:ga53ee37e22077f15f4cd7687bec548bcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga01594693b105625d950cb8d234d4afb6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#ga01594693b105625d950cb8d234d4afb6">uart_receive</a> (<a class="el" href="structuart__t.html">uart_t</a> *uart_id, uint8_t *data, uint16_t len, <a class="el" href="group___u_a_r_t.html#ga69d334701827bc97a2c2753b4597d5db">UART_OP_CFG</a> op)</td></tr>
<tr class="memdesc:ga01594693b105625d950cb8d234d4afb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start receiving data from UART receiver.  <a href="#ga01594693b105625d950cb8d234d4afb6">More...</a><br /></td></tr>
<tr class="separator:ga01594693b105625d950cb8d234d4afb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa252d4e13bd9d5274968a70bc1b88fd9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#gaa252d4e13bd9d5274968a70bc1b88fd9">uart_enable_flow_control</a> (<a class="el" href="structuart__t.html">uart_t</a> *uart_id)</td></tr>
<tr class="memdesc:gaa252d4e13bd9d5274968a70bc1b88fd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable UART flow control.  <a href="#gaa252d4e13bd9d5274968a70bc1b88fd9">More...</a><br /></td></tr>
<tr class="separator:gaa252d4e13bd9d5274968a70bc1b88fd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaacf9137e2b8da4986f1cb88d1b1b615c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#gaacf9137e2b8da4986f1cb88d1b1b615c">uart_disable_flow_control</a> (<a class="el" href="structuart__t.html">uart_t</a> *uart_id, uint32_t retries)</td></tr>
<tr class="memdesc:gaacf9137e2b8da4986f1cb88d1b1b615c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable UART flow control, if UART is inactive.  <a href="#gaacf9137e2b8da4986f1cb88d1b1b615c">More...</a><br /></td></tr>
<tr class="separator:gaacf9137e2b8da4986f1cb88d1b1b615c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6249bc6884e59a75cdedc9099cf42eb4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#ga6249bc6884e59a75cdedc9099cf42eb4">uart_init</a> (uint16_t baudr, uint8_t dlf_value, uint8_t mode)</td></tr>
<tr class="memdesc:ga6249bc6884e59a75cdedc9099cf42eb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize UART1.  <a href="#ga6249bc6884e59a75cdedc9099cf42eb4">More...</a><br /></td></tr>
<tr class="separator:ga6249bc6884e59a75cdedc9099cf42eb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef16c430ef9a5c79ca1b15fc12d79133"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#gaef16c430ef9a5c79ca1b15fc12d79133">uart_flow_on</a> (void)</td></tr>
<tr class="memdesc:gaef16c430ef9a5c79ca1b15fc12d79133"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable UART1 flow control.  <a href="#gaef16c430ef9a5c79ca1b15fc12d79133">More...</a><br /></td></tr>
<tr class="separator:gaef16c430ef9a5c79ca1b15fc12d79133"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8fa6369dbfec69ec62ead02bd5bcfe53"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#ga8fa6369dbfec69ec62ead02bd5bcfe53">uart_flow_off</a> (void)</td></tr>
<tr class="memdesc:ga8fa6369dbfec69ec62ead02bd5bcfe53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable UART1 flow control.  <a href="#ga8fa6369dbfec69ec62ead02bd5bcfe53">More...</a><br /></td></tr>
<tr class="separator:ga8fa6369dbfec69ec62ead02bd5bcfe53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa2ee484e01eb5a8ac34bbacc4580b3c3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#gaa2ee484e01eb5a8ac34bbacc4580b3c3">uart_finish_transfers</a> (void)</td></tr>
<tr class="memdesc:gaa2ee484e01eb5a8ac34bbacc4580b3c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finish current UART1 transfers.  <a href="#gaa2ee484e01eb5a8ac34bbacc4580b3c3">More...</a><br /></td></tr>
<tr class="separator:gaa2ee484e01eb5a8ac34bbacc4580b3c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2261e64ce574792337e9306fc8dbdfb2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#ga2261e64ce574792337e9306fc8dbdfb2">uart_read</a> (uint8_t *bufptr, uint32_t size, void(*callback)(uint8_t))</td></tr>
<tr class="memdesc:ga2261e64ce574792337e9306fc8dbdfb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start data reception.  <a href="#ga2261e64ce574792337e9306fc8dbdfb2">More...</a><br /></td></tr>
<tr class="separator:ga2261e64ce574792337e9306fc8dbdfb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9372a2be5a36dfa309be4f154b0dd590"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#ga9372a2be5a36dfa309be4f154b0dd590">uart_write</a> (uint8_t *bufptr, uint32_t size, void(*callback)(uint8_t))</td></tr>
<tr class="memdesc:ga9372a2be5a36dfa309be4f154b0dd590"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start data transmission.  <a href="#ga9372a2be5a36dfa309be4f154b0dd590">More...</a><br /></td></tr>
<tr class="separator:ga9372a2be5a36dfa309be4f154b0dd590"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga051c5642c97eb38c5c8f5b7b8da22fa2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#ga051c5642c97eb38c5c8f5b7b8da22fa2">uart_set_flow_off_retries_limit</a> (uint32_t limit)</td></tr>
<tr class="memdesc:ga051c5642c97eb38c5c8f5b7b8da22fa2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the limit of retries to disable flow control.  <a href="#ga051c5642c97eb38c5c8f5b7b8da22fa2">More...</a><br /></td></tr>
<tr class="separator:ga051c5642c97eb38c5c8f5b7b8da22fa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c99ed6c0aef9c7b47c9903aeb236837"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#ga4c99ed6c0aef9c7b47c9903aeb236837">UART2_Handler</a> (void)</td></tr>
<tr class="memdesc:ga4c99ed6c0aef9c7b47c9903aeb236837"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART2 interrupt handler.  <a href="#ga4c99ed6c0aef9c7b47c9903aeb236837">More...</a><br /></td></tr>
<tr class="separator:ga4c99ed6c0aef9c7b47c9903aeb236837"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga3125e5fec9a103b1cbf0dfce566621e3"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#ga3125e5fec9a103b1cbf0dfce566621e3">ext_wkup_uart_pins_t::rts_uart_port</a></td></tr>
<tr class="separator:ga3125e5fec9a103b1cbf0dfce566621e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7860982304013a9e0914fdd360b283ea"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#ga7860982304013a9e0914fdd360b283ea">ext_wkup_uart_pins_t::rts_uart_pin</a></td></tr>
<tr class="separator:ga7860982304013a9e0914fdd360b283ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>UART driver API. </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ga37ba06550cb3e2e3082df5d85ea96213"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga37ba06550cb3e2e3082df5d85ea96213">&#9670;&nbsp;</a></span>BAUD_RATE_DIV</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BAUD_RATE_DIV</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x</td><td>)</td>
          <td>&#160;&#160;&#160;((x &gt;&gt; 8) &amp; 0xFFFF)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate Baud Rate Divisor. </p>

</div>
</div>
<a id="gab290ff91fc7ac576a8c3050d59291d82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab290ff91fc7ac576a8c3050d59291d82">&#9670;&nbsp;</a></span>BAUD_RATE_FRAC</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BAUD_RATE_FRAC</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x</td><td>)</td>
          <td>&#160;&#160;&#160;(x &amp; 0xFF)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate Baud Rate Fractional part. </p>

</div>
</div>
<a id="ga8d69bf04d07af4fbbab5a8bd291f65ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8d69bf04d07af4fbbab5a8bd291f65ff">&#9670;&nbsp;</a></span>UART1</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UART1&#160;&#160;&#160;(<a class="el" href="structuart__t.html">uart_t</a> *)  UART_RBR_THR_DLL_REG</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>UART Base Address. </p>

</div>
</div>
<a id="ga7f6bd6eb89ae2eeae97af4207ebe3cde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7f6bd6eb89ae2eeae97af4207ebe3cde">&#9670;&nbsp;</a></span>UART2</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UART2&#160;&#160;&#160;(<a class="el" href="structuart__t.html">uart_t</a> *)  UART2_RBR_THR_DLL_REG</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>UART2 Base Address. </p>

</div>
</div>
<a id="ga4dfd8a0416bf7498e942a840df5d80ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4dfd8a0416bf7498e942a840df5d80ec">&#9670;&nbsp;</a></span>UART_ENV</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UART_ENV</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">id</td><td>)</td>
          <td>&#160;&#160;&#160;(&amp;uartn_env[((id) == <a class="el" href="group___u_a_r_t.html#ga8d69bf04d07af4fbbab5a8bd291f65ff">UART1</a> ? 0 : 1)])</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Macro to get the environment from UART ID. </p>

</div>
</div>
<a id="ga0817c0cf2ad6f72810fa1a78565b3022"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0817c0cf2ad6f72810fa1a78565b3022">&#9670;&nbsp;</a></span>UART_FIFOSE_RT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UART_FIFOSE_RT&#160;&#160;&#160;(0x00C0)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>RCVR Trigger. </p>

</div>
</div>
<a id="ga92d985da6329d3e314a091028c6fc951"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga92d985da6329d3e314a091028c6fc951">&#9670;&nbsp;</a></span>UART_ID</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UART_ID</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">id</td><td>)</td>
          <td>&#160;&#160;&#160;((id) == <a class="el" href="group___u_a_r_t.html#ga8d69bf04d07af4fbbab5a8bd291f65ff">UART1</a> ? 0 : 1)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Macro to get the ID from UART Base Address. </p>

</div>
</div>
<a id="ga04a94e06527ed4faa4174427ef008cc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga04a94e06527ed4faa4174427ef008cc2">&#9670;&nbsp;</a></span>UART_IID0_FIFOE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UART_IID0_FIFOE&#160;&#160;&#160;(0x0001)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>FIFO Enable. </p>

</div>
</div>
<a id="ga7a8ce76c89c17aa08a03b76b122c4d3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7a8ce76c89c17aa08a03b76b122c4d3c">&#9670;&nbsp;</a></span>UART_IID1_RFIFOE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UART_IID1_RFIFOE&#160;&#160;&#160;(0x0002)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>RCVR FIFO Reset. </p>

</div>
</div>
<a id="ga60ca04adbfa38dc1df82cf2b37c0b501"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga60ca04adbfa38dc1df82cf2b37c0b501">&#9670;&nbsp;</a></span>UART_IID2_XFIFOR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UART_IID2_XFIFOR&#160;&#160;&#160;(0x0004)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>XMIT FIFO Reset. </p>

</div>
</div>
<a id="ga67d2eb8177cfbb70307346d0e78f1ec2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga67d2eb8177cfbb70307346d0e78f1ec2">&#9670;&nbsp;</a></span>UART_IID3_DMAM</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UART_IID3_DMAM&#160;&#160;&#160;(0x0008)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>DMA Mode. </p>

</div>
</div>
<a id="ga198bd0474d370c0b50733b98a4205c65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga198bd0474d370c0b50733b98a4205c65">&#9670;&nbsp;</a></span>UART_INTR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UART_INTR</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">id</td><td>)</td>
          <td>&#160;&#160;&#160;((id) == <a class="el" href="group___u_a_r_t.html#ga8d69bf04d07af4fbbab5a8bd291f65ff">UART1</a>  ? (UART_IRQn) : (UART2_IRQn))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Macro to get the UART IRQ from UART ID. </p>

</div>
</div>
<a id="ga9b5ddd24650e9e56570b3d54d8c7d819"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9b5ddd24650e9e56570b3d54d8c7d819">&#9670;&nbsp;</a></span>UART_TET</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UART_TET&#160;&#160;&#160;(0x0030)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>TX Empty Trigger. </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga587d4439909898b9ae38e9aca950ae02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga587d4439909898b9ae38e9aca950ae02">&#9670;&nbsp;</a></span>uart_cb_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* uart_cb_t) (uint16_t data_cnt)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transmit callback type definition. </p>

</div>
</div>
<a id="ga54e57286e0cd5aa49304eff5ed78156c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga54e57286e0cd5aa49304eff5ed78156c">&#9670;&nbsp;</a></span>uart_err_cb_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* uart_err_cb_t) (<a class="el" href="structuart__t.html">uart_t</a> *uart, uint8_t uart_err_status)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Error callback type definition. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ga2a2e6711c13f801499299cf273a5e4e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2a2e6711c13f801499299cf273a5e4e6">&#9670;&nbsp;</a></span>UART_AFCE_CFG</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___u_a_r_t.html#ga2a2e6711c13f801499299cf273a5e4e6">UART_AFCE_CFG</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Auto flow control. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga2a2e6711c13f801499299cf273a5e4e6ac1efdec29ec5a93769ee6b3ebb7f2c9e"></a>UART_AFCE_DIS&#160;</td><td class="fielddoc"><p>Disable Autoflow control. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga2a2e6711c13f801499299cf273a5e4e6adf7761399acd12c42452b11d01493ad3"></a>UART_AFCE_EN&#160;</td><td class="fielddoc"><p>Enable Autoflow control. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga2ebef9ab11e56d9d914a270f8a895034"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2ebef9ab11e56d9d914a270f8a895034">&#9670;&nbsp;</a></span>UART_BAUDRATE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___u_a_r_t.html#ga2ebef9ab11e56d9d914a270f8a895034">UART_BAUDRATE</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Baud rates dividers The defined values comprise the values of 3 registers: DLH, DLL, DLF. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga2ebef9ab11e56d9d914a270f8a895034a82d65082b6f8df08e8d52ae147256060"></a>UART_BAUDRATE_1000000&#160;</td><td class="fielddoc"><p>1M Baud Rate </p>
</td></tr>
<tr><td class="fieldname"><a id="gga2ebef9ab11e56d9d914a270f8a895034a404611687ebff8a0f12677fffd27535b"></a>UART_BAUDRATE_921600&#160;</td><td class="fielddoc"><p>921600 Baud Rate </p>
</td></tr>
<tr><td class="fieldname"><a id="gga2ebef9ab11e56d9d914a270f8a895034a4d33d08d6ce7d7436722f757b31d669e"></a>UART_BAUDRATE_500000&#160;</td><td class="fielddoc"><p>500000 Baud Rate </p>
</td></tr>
<tr><td class="fieldname"><a id="gga2ebef9ab11e56d9d914a270f8a895034a045376206230ea6263553424697fbe2e"></a>UART_BAUDRATE_460800&#160;</td><td class="fielddoc"><p>460800 Baud Rate </p>
</td></tr>
<tr><td class="fieldname"><a id="gga2ebef9ab11e56d9d914a270f8a895034a2655448bc65d60f801362784520b8b7f"></a>UART_BAUDRATE_230400&#160;</td><td class="fielddoc"><p>230400 Baud Rate </p>
</td></tr>
<tr><td class="fieldname"><a id="gga2ebef9ab11e56d9d914a270f8a895034a8bfbaf4f7fcc3591d3f40fedc503501e"></a>UART_BAUDRATE_115200&#160;</td><td class="fielddoc"><p>115200 Baud Rate </p>
</td></tr>
<tr><td class="fieldname"><a id="gga2ebef9ab11e56d9d914a270f8a895034a0a4f1f97b369196795153a10dcc9d5cf"></a>UART_BAUDRATE_57600&#160;</td><td class="fielddoc"><p>57600 Baud Rate </p>
</td></tr>
<tr><td class="fieldname"><a id="gga2ebef9ab11e56d9d914a270f8a895034a21dd883e9be8390ef1d034edad397167"></a>UART_BAUDRATE_38400&#160;</td><td class="fielddoc"><p>38400 Baud Rate </p>
</td></tr>
<tr><td class="fieldname"><a id="gga2ebef9ab11e56d9d914a270f8a895034a60fd45cbdbb32488a06268f504528ce1"></a>UART_BAUDRATE_28800&#160;</td><td class="fielddoc"><p>28800 Baud Rate </p>
</td></tr>
<tr><td class="fieldname"><a id="gga2ebef9ab11e56d9d914a270f8a895034a2eacecb72086c5387c99225aa8f63bf7"></a>UART_BAUDRATE_19200&#160;</td><td class="fielddoc"><p>19200 Baud Rate </p>
</td></tr>
<tr><td class="fieldname"><a id="gga2ebef9ab11e56d9d914a270f8a895034af4ec9a8ee0b6255775d2ecae5f180aa7"></a>UART_BAUDRATE_14400&#160;</td><td class="fielddoc"><p>14400 Baud Rate </p>
</td></tr>
<tr><td class="fieldname"><a id="gga2ebef9ab11e56d9d914a270f8a895034a643943379183cdf9d8c0dd9f7b5dcd29"></a>UART_BAUDRATE_9600&#160;</td><td class="fielddoc"><p>9600 Baud Rate </p>
</td></tr>
<tr><td class="fieldname"><a id="gga2ebef9ab11e56d9d914a270f8a895034abe866ffb30dbc65f9090023cf3ac04ea"></a>UART_BAUDRATE_4800&#160;</td><td class="fielddoc"><p>4800 Baud Rate </p>
</td></tr>
<tr><td class="fieldname"><a id="gga2ebef9ab11e56d9d914a270f8a895034a647219a441d89f39dcc11a738e294c53"></a>UART_BAUDRATE_2400&#160;</td><td class="fielddoc"><p>2400 Baud Rate </p>
</td></tr>
</table>

</div>
</div>
<a id="gabd218b2905cb2bad7f9d44912d63be3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabd218b2905cb2bad7f9d44912d63be3d">&#9670;&nbsp;</a></span>UART_BIT_CFG</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___u_a_r_t.html#gabd218b2905cb2bad7f9d44912d63be3d">UART_BIT_CFG</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generic enable/disable enum for UART driver. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggabd218b2905cb2bad7f9d44912d63be3dac3ca41d778103dd4f807464e022bea47"></a>UART_BIT_DIS&#160;</td><td class="fielddoc"><p>Disable. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggabd218b2905cb2bad7f9d44912d63be3da6962720bc8dfa29962d1d47ce8c02950"></a>UART_BIT_EN&#160;</td><td class="fielddoc"><p>Enable. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga24f73385af2d9c46d405402760a30766"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga24f73385af2d9c46d405402760a30766">&#9670;&nbsp;</a></span>UART_DATABITS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___u_a_r_t.html#ga24f73385af2d9c46d405402760a30766">UART_DATABITS</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Character format. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga24f73385af2d9c46d405402760a30766a1689317330cc55b4345c8a6995ce1fad"></a>UART_DATABITS_5&#160;</td><td class="fielddoc"><p>5 Data bits format </p>
</td></tr>
<tr><td class="fieldname"><a id="gga24f73385af2d9c46d405402760a30766ab468f4f38a9d73b03d2eeee413879283"></a>UART_DATABITS_6&#160;</td><td class="fielddoc"><p>6 Data bits format </p>
</td></tr>
<tr><td class="fieldname"><a id="gga24f73385af2d9c46d405402760a30766a941f53895de35cb17c5b5ae5e57a02b9"></a>UART_DATABITS_7&#160;</td><td class="fielddoc"><p>7 Data bits format </p>
</td></tr>
<tr><td class="fieldname"><a id="gga24f73385af2d9c46d405402760a30766af080420d870f7b3917bd59107ac4c153"></a>UART_DATABITS_8&#160;</td><td class="fielddoc"><p>8 Data bits format </p>
</td></tr>
</table>

</div>
</div>
<a id="ga55de0ec52ddacb716672e99b81eedfef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga55de0ec52ddacb716672e99b81eedfef">&#9670;&nbsp;</a></span>UART_DMA_CFG</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___u_a_r_t.html#ga55de0ec52ddacb716672e99b81eedfef">UART_DMA_CFG</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>UART DMA support. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga55de0ec52ddacb716672e99b81eedfefa1b8df60eb38bbb0a887c9c167f473500"></a>UART_DMA_DISABLE&#160;</td><td class="fielddoc"><p>UART does not support DMA transactions. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga55de0ec52ddacb716672e99b81eedfefa9726c6224c09fac87c81d71a192fc032"></a>UART_DMA_ENABLE&#160;</td><td class="fielddoc"><p>UART supports DMA transactions. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga8fc237bc57dd45252e96589aa1a1e7f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8fc237bc57dd45252e96589aa1a1e7f6">&#9670;&nbsp;</a></span>UART_DMA_CHANNEL_CFG</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___u_a_r_t.html#ga8fc237bc57dd45252e96589aa1a1e7f6">UART_DMA_CHANNEL_CFG</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>UART DMA channel configuration. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga8fc237bc57dd45252e96589aa1a1e7f6aeb45e06b6f755e24127c3568d56edc0f"></a>UART_DMA_CHANNEL_01&#160;</td><td class="fielddoc"><p>Rx = Channel 0, Tx = Channel 1. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga8fc237bc57dd45252e96589aa1a1e7f6a642d7c49dc907aafd21d87f1d2041939"></a>UART_DMA_CHANNEL_23&#160;</td><td class="fielddoc"><p>Rx = Channel 2, Tx = Channel 3. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga1d34e34ab58c383449603db0b5cd4e89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1d34e34ab58c383449603db0b5cd4e89">&#9670;&nbsp;</a></span>UART_FIFO_CFG</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___u_a_r_t.html#ga1d34e34ab58c383449603db0b5cd4e89">UART_FIFO_CFG</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Use FIFO. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga1d34e34ab58c383449603db0b5cd4e89a1980b9d1c707c322c73cfecca3e1092a"></a>UART_FIFO_DIS&#160;</td><td class="fielddoc"><p>Disable FIFO. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga1d34e34ab58c383449603db0b5cd4e89ae70293a4941e4be08236f415b1532fa1"></a>UART_FIFO_EN&#160;</td><td class="fielddoc"><p>Enable FIFO. </p>
</td></tr>
</table>

</div>
</div>
<a id="gacd8e8830a5d0b31458f1825de0ca1c4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacd8e8830a5d0b31458f1825de0ca1c4e">&#9670;&nbsp;</a></span>UART_INT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___u_a_r_t.html#gacd8e8830a5d0b31458f1825de0ca1c4e">UART_INT</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interrupt Identification codes. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggacd8e8830a5d0b31458f1825de0ca1c4ea3fd0767497a95f15a101c31e19e2843b"></a>UART_INT_NO_INT_PEND&#160;</td><td class="fielddoc"><p>No interrupt pending. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggacd8e8830a5d0b31458f1825de0ca1c4ea7d745437f6ce62a2b0d94776ffd43fb9"></a>UART_INT_THR_EMPTY&#160;</td><td class="fielddoc"><p>THR empty interrupt. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggacd8e8830a5d0b31458f1825de0ca1c4ea69db21de2d2e7be66976fcd6231397c0"></a>UART_INT_RECEIVED_AVAILABLE&#160;</td><td class="fielddoc"><p>Received data available interrupt. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggacd8e8830a5d0b31458f1825de0ca1c4ea7aa86ea71f117e40288ab1e201e3221b"></a>UART_INT_RECEIVE_LINE_STAT&#160;</td><td class="fielddoc"><p>Receiver line status interrupt. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggacd8e8830a5d0b31458f1825de0ca1c4ea2b463afcd99d695bc7286585fb04977a"></a>UART_INT_BUSY_DETECTED&#160;</td><td class="fielddoc"><p>Busy detect interrupt. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggacd8e8830a5d0b31458f1825de0ca1c4ea44450caa0b760aa1e5ef35b23104b306"></a>UART_INT_TIMEOUT&#160;</td><td class="fielddoc"><p>Timeout interrupt. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga69d334701827bc97a2c2753b4597d5db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga69d334701827bc97a2c2753b4597d5db">&#9670;&nbsp;</a></span>UART_OP_CFG</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___u_a_r_t.html#ga69d334701827bc97a2c2753b4597d5db">UART_OP_CFG</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mode of operation. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga69d334701827bc97a2c2753b4597d5dbae1aa531fac16efd1547d30ae661c7148"></a>UART_OP_BLOCKING&#160;</td><td class="fielddoc"><p>Blocking operation (no interrupts - no DMA) </p>
</td></tr>
<tr><td class="fieldname"><a id="gga69d334701827bc97a2c2753b4597d5dbac6533ccaa1e3b0e2c6672cee6db4221e"></a>UART_OP_INTR&#160;</td><td class="fielddoc"><p>Interrupt driven operation. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga69d334701827bc97a2c2753b4597d5dba684d224393401c4a1ffb41166da828e6"></a>UART_OP_DMA&#160;</td><td class="fielddoc"><p>DMA driven operation. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga24fd4dba815fc40fbd8e8c37dbf87c7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga24fd4dba815fc40fbd8e8c37dbf87c7a">&#9670;&nbsp;</a></span>UART_PARITY</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___u_a_r_t.html#ga24fd4dba815fc40fbd8e8c37dbf87c7a">UART_PARITY</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parity. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga24fd4dba815fc40fbd8e8c37dbf87c7aaa80d2d8ea61454045ebe71d155e85b3d"></a>UART_PARITY_NONE&#160;</td><td class="fielddoc"><p>No parity. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga24fd4dba815fc40fbd8e8c37dbf87c7aad90cc425f5ba447773a44a75be6593e2"></a>UART_PARITY_ODD&#160;</td><td class="fielddoc"><p>Odd parity. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga24fd4dba815fc40fbd8e8c37dbf87c7aad908a637b1dd23f93b149dd2d8bdfdb8"></a>UART_PARITY_EVEN&#160;</td><td class="fielddoc"><p>Even parity. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga56aaf477e65211c6e6858894d1590fd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga56aaf477e65211c6e6858894d1590fd7">&#9670;&nbsp;</a></span>UART_RX_FIFO_LEVEL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___u_a_r_t.html#ga56aaf477e65211c6e6858894d1590fd7">UART_RX_FIFO_LEVEL</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>UART RX FIFO level. Select the trigger level in the receiver FIFO at which the Received Data Available Interrupt will be generated. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga56aaf477e65211c6e6858894d1590fd7ad9cd1fd081c164f6fed9019e67714f2e"></a>UART_RX_FIFO_LEVEL_0&#160;</td><td class="fielddoc"><p>1 character in FIFO </p>
</td></tr>
<tr><td class="fieldname"><a id="gga56aaf477e65211c6e6858894d1590fd7acf6f77fab0372d75b7aaa6c519160b5a"></a>UART_RX_FIFO_LEVEL_1&#160;</td><td class="fielddoc"><p>FIFO 1/4 full. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga56aaf477e65211c6e6858894d1590fd7ada8efcab12126cb8c92021c17f41a8aa"></a>UART_RX_FIFO_LEVEL_2&#160;</td><td class="fielddoc"><p>FIFO 1/2 full. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga56aaf477e65211c6e6858894d1590fd7a04d74c8bc65a13aef3607e74961f26e5"></a>UART_RX_FIFO_LEVEL_3&#160;</td><td class="fielddoc"><p>FIFO 2 less than full. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga0528dc4401f43d2c1ce20479a635c327"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0528dc4401f43d2c1ce20479a635c327">&#9670;&nbsp;</a></span>UART_STATUS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___u_a_r_t.html#ga0528dc4401f43d2c1ce20479a635c327">UART_STATUS</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Status enum for UART driver. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga0528dc4401f43d2c1ce20479a635c327adf538d3c816b049a4cb9cceefc43884c"></a>UART_ERR_NO_ERROR&#160;</td><td class="fielddoc"><p>No error. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga0528dc4401f43d2c1ce20479a635c327adae9d030ead331c9693a5a53e6277726"></a>UART_ERR_BUSY_ERROR&#160;</td><td class="fielddoc"><p>Busy Error. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga0528dc4401f43d2c1ce20479a635c327ac3222c4accd846f6c1a569b6a347eeb5"></a>UART_ERR_OVERRUN_ERROR&#160;</td><td class="fielddoc"><p>Overrun error bit. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga0528dc4401f43d2c1ce20479a635c327a5b74c7bf4dde7c35f5e1dd2d4335ce25"></a>UART_ERR_PARITY_ERROR&#160;</td><td class="fielddoc"><p>Parity Error. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga0528dc4401f43d2c1ce20479a635c327a5841e1ca9586d48e013f1a6a610535f4"></a>UART_ERR_FRAMING_ERROR&#160;</td><td class="fielddoc"><p>Framing Error. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga0528dc4401f43d2c1ce20479a635c327a5044b44e72bdb8702767f399bfb876e3"></a>UART_ERR_BREAK_ERROR&#160;</td><td class="fielddoc"><p>Break Interrupt. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga0528dc4401f43d2c1ce20479a635c327a67e5c2ab516a138000192857d4769b54"></a>UART_ERR_RX_FIFO_ERROR&#160;</td><td class="fielddoc"><p>Receiver FIFO Error. </p>
</td></tr>
</table>

</div>
</div>
<a id="gacbd51ac613ec824eeb73a5b6bf743ca6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacbd51ac613ec824eeb73a5b6bf743ca6">&#9670;&nbsp;</a></span>UART_STOPBITS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___u_a_r_t.html#gacbd51ac613ec824eeb73a5b6bf743ca6">UART_STOPBITS</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stop bits. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggacbd51ac613ec824eeb73a5b6bf743ca6ab1c6c3da76951f5a1817859f83ddd9fa"></a>UART_STOPBITS_1&#160;</td><td class="fielddoc"><p>1 stop bit </p>
</td></tr>
<tr><td class="fieldname"><a id="ggacbd51ac613ec824eeb73a5b6bf743ca6af4b730b061af3ef2004c360c158ffef8"></a>UART_STOPBITS_2&#160;</td><td class="fielddoc"><p>1.5 stop bits when DLS is 5 bits, else 2 stop bits </p>
</td></tr>
</table>

</div>
</div>
<a id="ga10962da2c5916d3eb7890bab6ed7b3f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga10962da2c5916d3eb7890bab6ed7b3f4">&#9670;&nbsp;</a></span>UART_TX_FIFO_LEVEL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___u_a_r_t.html#ga10962da2c5916d3eb7890bab6ed7b3f4">UART_TX_FIFO_LEVEL</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>UART TX FIFO level. Select the empty threshold level at which the THRE Interrupts will be generated. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga10962da2c5916d3eb7890bab6ed7b3f4a3349f130d24460a0d818c66cf7cd734e"></a>UART_TX_FIFO_LEVEL_0&#160;</td><td class="fielddoc"><p>FIFO empty. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga10962da2c5916d3eb7890bab6ed7b3f4a3b6d6b02236f159dbfbc7ce5b3338017"></a>UART_TX_FIFO_LEVEL_1&#160;</td><td class="fielddoc"><p>2 characters in FIFO </p>
</td></tr>
<tr><td class="fieldname"><a id="gga10962da2c5916d3eb7890bab6ed7b3f4a3b91e5a3f0ad215acfd2114f41a41d97"></a>UART_TX_FIFO_LEVEL_2&#160;</td><td class="fielddoc"><p>FIFO 1/4 full. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga10962da2c5916d3eb7890bab6ed7b3f4a4e3fe927649eb93b162730b94104396c"></a>UART_TX_FIFO_LEVEL_3&#160;</td><td class="fielddoc"><p>FIFO 1/2 full. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga4c99ed6c0aef9c7b47c9903aeb236837"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4c99ed6c0aef9c7b47c9903aeb236837">&#9670;&nbsp;</a></span>UART2_Handler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UART2_Handler </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>UART2 interrupt handler. </p>

</div>
</div>
<a id="gac54223e272335cb7f84a7b60663bbe18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac54223e272335cb7f84a7b60663bbe18">&#9670;&nbsp;</a></span>uart_afce_getf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_FORCEINLINE uint16_t uart_afce_getf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structuart__t.html">uart_t</a> *&#160;</td>
          <td class="paramname"><em>uart_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get Auto Flow Control configuration of UART. </p>
<dl class="section note"><dt>Note</dt><dd>HW flowcontrol is not supported in UART2 of DA14531</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">uart_id</td><td>Identifies which UART to use </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>uint16_t UART_AFCE_CFG </dd></dl>

</div>
</div>
<a id="gaad24d9f5043b06fb70553477fd2527b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaad24d9f5043b06fb70553477fd2527b0">&#9670;&nbsp;</a></span>uart_afce_setf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_FORCEINLINE void uart_afce_setf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structuart__t.html">uart_t</a> *&#160;</td>
          <td class="paramname"><em>uart_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_a_r_t.html#ga2a2e6711c13f801499299cf273a5e4e6">UART_AFCE_CFG</a>&#160;</td>
          <td class="paramname"><em>afce</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable/Disable Auto Flow Control. </p>
<p>Writeable only when AFCE_MODE == Enabled, always readable. When FIFOs are enabled and the Auto Flow Control Enable (AFCE) bit is set, Auto Flow Control features are enabled.</p>
<dl class="section note"><dt>Note</dt><dd>HW flowcontrol is not supported in UART2 of DA14531</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">uart_id</td><td>Identifies which UART to use </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">afce</td><td>UART_AFCE_CFG </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac6557bb02351d0e112dcf221e9946d3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac6557bb02351d0e112dcf221e9946d3b">&#9670;&nbsp;</a></span>uart_baudrate_setf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void uart_baudrate_setf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structuart__t.html">uart_t</a> *&#160;</td>
          <td class="paramname"><em>uart_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_a_r_t.html#ga2ebef9ab11e56d9d914a270f8a895034">UART_BAUDRATE</a>&#160;</td>
          <td class="paramname"><em>baud_rate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set Baud rate. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">uart_id</td><td>Identifies which UART to use </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">baud_rate</td><td>UART_BAUDRATE </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gacb5c5e15903d882ec93b832b064fe318"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacb5c5e15903d882ec93b832b064fe318">&#9670;&nbsp;</a></span>uart_bc_setf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_FORCEINLINE void uart_bc_setf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structuart__t.html">uart_t</a> *&#160;</td>
          <td class="paramname"><em>uart_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_a_r_t.html#gabd218b2905cb2bad7f9d44912d63be3d">UART_BIT_CFG</a>&#160;</td>
          <td class="paramname"><em>bc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable/Disable Break Control Bit. </p>
<p>This is used to cause a break condition to be transmitted to the receiving device. If set to one the serial output is forced to the spacing (logic 0) state. When not in Loopback Mode, as determined by MCR[4], the sout line is forced low until the Break bit is cleared. If active (MCR[6] set to one) the sir_out_n line is continuously pulsed. When in Loopback Mode, the break condition is internally looped back to the receiver and the sir_out_n line is forced low. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">uart_id</td><td>Identifies which UART to use </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bc</td><td>UART_BIT_CFG </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga182d115a153688ad6fb585f5dea1dabe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga182d115a153688ad6fb585f5dea1dabe">&#9670;&nbsp;</a></span>uart_break_ctrl_shd_setf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_FORCEINLINE void uart_break_ctrl_shd_setf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structuart__t.html">uart_t</a> *&#160;</td>
          <td class="paramname"><em>uart_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_a_r_t.html#gabd218b2905cb2bad7f9d44912d63be3d">UART_BIT_CFG</a>&#160;</td>
          <td class="paramname"><em>uart_break_ctrl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shadow Break Control Bit. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">uart_id</td><td>Identifies which UART to use </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uart_break_ctrl</td><td>UART_BIT_CFG </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4067366f6aff74ffc5bdcd1ef2da1c99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4067366f6aff74ffc5bdcd1ef2da1c99">&#9670;&nbsp;</a></span>uart_cts_getf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_FORCEINLINE uint16_t uart_cts_getf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structuart__t.html">uart_t</a> *&#160;</td>
          <td class="paramname"><em>uart_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear to Send. </p>
<p>This is used to indicate the current state of the modem control line cts_n. This bit is the complement of cts_n. When the Clear to Send input (cts_n) is asserted it is an indication that the modem or data set is ready to exchange data with the UART Ctrl. In Loopback Mode (MCR[4] = 1), CTS is the same as MCR1: (RTS). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">uart_id</td><td>Identifies which UART to use </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>uint16_t 0 = cts_n input is de-asserted (logic 1), 1 = cts_n input is asserted (logic 0) </dd></dl>
<dl class="section note"><dt>Note</dt><dd>HW flowcontrol is not supported in UART2 of DA14531 </dd></dl>

</div>
</div>
<a id="ga00bcdc5b999362937e4424b3a3cf4259"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga00bcdc5b999362937e4424b3a3cf4259">&#9670;&nbsp;</a></span>uart_data_ready_getf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_FORCEINLINE uint16_t uart_data_ready_getf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structuart__t.html">uart_t</a> *&#160;</td>
          <td class="paramname"><em>uart_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Data Ready bit. </p>
<p>This is used to indicate that the receiver contains at least one character in the RBR or the receiver FIFO. * This bit is cleared when the RBR is read in non-FIFO mode, or when the receiver FIFO is empty, in FIFO mode. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">uart_id</td><td>Identifies which UART to use </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>uint16_t 0 = no data ready, 1 = data ready </dd></dl>

</div>
</div>
<a id="gaa46e97716f060125d09c34c75dc7115d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa46e97716f060125d09c34c75dc7115d">&#9670;&nbsp;</a></span>uart_dcts_getf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_FORCEINLINE uint16_t uart_dcts_getf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structuart__t.html">uart_t</a> *&#160;</td>
          <td class="paramname"><em>uart_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delta Clear to Send. </p>
<p>This is used to indicate that the modem control line cts_n has changed since the last time the MSR was read. Reading the MSR clears the DCTS bit. In Loopback Mode (MCR[4] = 1), DCTS reflects changes on MCR1: (RTS). </p><dl class="section note"><dt>Note</dt><dd>If the DCTS bit is not set and the cts_n signal is asserted (low) and a reset occurs (software or otherwise), then the DCTS bit is set when the reset is removed if the cts_n signal remains asserted. </dd>
<dd>
DCTS is not supported in DA14531 </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">uart_id</td><td>Identifies which UART to use </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>uint16_t 0 = no change on cts_n since last read of MSR, 1 = change on cts_n since last read of MSR </dd></dl>

</div>
</div>
<a id="ga62367146f0b04d10a13cc71111955504"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga62367146f0b04d10a13cc71111955504">&#9670;&nbsp;</a></span>uart_disable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void uart_disable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structuart__t.html">uart_t</a> *&#160;</td>
          <td class="paramname"><em>uart_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reset UART and disable clock for UART peripheral. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">uart_id</td><td>Identifies which UART to use </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaacf9137e2b8da4986f1cb88d1b1b615c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaacf9137e2b8da4986f1cb88d1b1b615c">&#9670;&nbsp;</a></span>uart_disable_flow_control()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool uart_disable_flow_control </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structuart__t.html">uart_t</a> *&#160;</td>
          <td class="paramname"><em>uart_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>retries</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disable UART flow control, if UART is inactive. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">uart_id</td><td>Identifies which UART to use. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">retries</td><td>Number of times to retry disabling flow control, if UART transmitter is active. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if flow control has been disabled, else false. </dd></dl>

</div>
</div>
<a id="ga8d1931bdc580fee277b84d682c21e9d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8d1931bdc580fee277b84d682c21e9d8">&#9670;&nbsp;</a></span>uart_dlab_setf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_FORCEINLINE void uart_dlab_setf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structuart__t.html">uart_t</a> *&#160;</td>
          <td class="paramname"><em>uart_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_a_r_t.html#gabd218b2905cb2bad7f9d44912d63be3d">UART_BIT_CFG</a>&#160;</td>
          <td class="paramname"><em>dlab</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable/Disable Divisor Latch Access Bit. </p>
<p>This bit is used to enable reading and writing of the Divisor Latch register (DLL and DLH) to set the baud rate of the UART. This bit must be cleared after initial baud rate setup in order to access other registers. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">uart_id</td><td>Identifies which UART to use </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dlab</td><td>UART_BIT_CFG </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac35f7ef0e0421cf2feb09d238d6a4919"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac35f7ef0e0421cf2feb09d238d6a4919">&#9670;&nbsp;</a></span>uart_dlf_getf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_FORCEINLINE uint16_t uart_dlf_getf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structuart__t.html">uart_t</a> *&#160;</td>
          <td class="paramname"><em>uart_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The fractional value is added to integer value set by DLH, DLL. </p>
<p>Fractional value is determined by (Divisor Fraction value)/(2^DLF_SIZE). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">uart_id</td><td>Identifies which UART to use </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>uint16_t dlf value </dd></dl>

</div>
</div>
<a id="ga6dc9f74e185662f3a3be1cc7ef1ea31c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6dc9f74e185662f3a3be1cc7ef1ea31c">&#9670;&nbsp;</a></span>uart_dlf_setf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_FORCEINLINE void uart_dlf_setf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structuart__t.html">uart_t</a> *&#160;</td>
          <td class="paramname"><em>uart_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dlf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The fractional value is added to integer value set by DLH, DLL. </p>
<p>Fractional value is determined by (Divisor Fraction value)/(2^DLF_SIZE). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">uart_id</td><td>Identifies which UART to use </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dlf</td><td>uint8_t </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae8afa777422c931fad2abcbb22a1c60d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae8afa777422c931fad2abcbb22a1c60d">&#9670;&nbsp;</a></span>uart_dlh_setf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_FORCEINLINE void uart_dlh_setf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structuart__t.html">uart_t</a> *&#160;</td>
          <td class="paramname"><em>uart_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write byte to Divisor Latch (High) Register. </p>
<p>Writes the upper 8-bits of the 16-bit divisor for the UART. This register may only be accessed when the DLAB bit (LCR[7]) is set. Upper 8-bits of a 16-bit, read/write, Divisor Latch register that contains the baud rate divisor for the UART. This register may be accessed only when the DLAB bit (LCR[7]) is set. The output baud rate is equal to the serial clock frequency divided by sixteen times the value of the baud rate divisor, as follows: baud rate = (serial clock freq) / (16 * divisor) Note that with the Divisor Latch Registers (DLL and DLH) set to zero, the baud clock is disabled and no serial communications will occur. Also, once the DLL is set, at least 8 clock cycles of the slowest uart clock should be allowed to pass before transmitting or receiving data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">uart_id</td><td>Identifies which UART to use </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>DLH value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga7c894d837702a10bb2d02b2e12ed5d4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7c894d837702a10bb2d02b2e12ed5d4d">&#9670;&nbsp;</a></span>uart_dll_setf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_FORCEINLINE void uart_dll_setf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structuart__t.html">uart_t</a> *&#160;</td>
          <td class="paramname"><em>uart_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write byte to Divisor Latch (Low) Register. </p>
<p>Writes the lower 8-bits of the 16-bit divisor for the UART. This register may only be accessed when the DLAB bit (LCR[7]) is set. This register makes up the lower 8-bits of a 16-bit, read/write, Divisor Latch register that contains the baud rate divisor for the UART. This register may only be accessed when the DLAB bit (LCR[7]) is set. The output baud rate is equal to the serial clock (sclk) frequency divided by sixteen times the value of the baud rate divisor, as follows: baud rate = (serial clock freq) / (16 * divisor) Note that with the Divisor Latch Registers (DLL and DLH) set to zero, the baud clock is disabled and no serial communications will occur. Also, once the DLL is set, at least 8 clock cycles of the slowest uart clock should be allowed to pass before transmitting or receiving data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">uart_id</td><td>Identifies which UART to use </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>DLL value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gacc71455c02d9fb7fef33691fac3938c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacc71455c02d9fb7fef33691fac3938c1">&#9670;&nbsp;</a></span>uart_dls_getf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_FORCEINLINE uint16_t uart_dls_getf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structuart__t.html">uart_t</a> *&#160;</td>
          <td class="paramname"><em>uart_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get Data Length Select configuration of UART. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">uart_id</td><td>Identifies which UART to use </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>UART_DATABITS Data bits configuration </dd></dl>

</div>
</div>
<a id="ga9ec3a051e774d36fcc7bf29f330644f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9ec3a051e774d36fcc7bf29f330644f2">&#9670;&nbsp;</a></span>uart_dls_setf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_FORCEINLINE void uart_dls_setf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structuart__t.html">uart_t</a> *&#160;</td>
          <td class="paramname"><em>uart_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_a_r_t.html#ga24f73385af2d9c46d405402760a30766">UART_DATABITS</a>&#160;</td>
          <td class="paramname"><em>dls</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set Data Length Select. </p>
<p>This is used to select the number of data bits per character that the peripheral transmits and receives. The number of bit that may be selected areas follows: [00] = 5 bits, [01] = 6 bits, [10] = 7 bits, [11] = 8 bits </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">uart_id</td><td>Identifies which UART to use </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dls</td><td>UART_DATABITS </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5cec7693c0bae9e14939aabf6751ac1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5cec7693c0bae9e14939aabf6751ac1d">&#9670;&nbsp;</a></span>uart_dma_mode_shd_setf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_FORCEINLINE void uart_dma_mode_shd_setf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structuart__t.html">uart_t</a> *&#160;</td>
          <td class="paramname"><em>uart_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dma_mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shadow DMA Mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">uart_id</td><td>Identifies which UART to use </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dma_mode</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga331387733c05fe11c9c6523469908f5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga331387733c05fe11c9c6523469908f5d">&#9670;&nbsp;</a></span>uart_dmasa_setf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_FORCEINLINE void uart_dmasa_setf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structuart__t.html">uart_t</a> *&#160;</td>
          <td class="paramname"><em>uart_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_a_r_t.html#gabd218b2905cb2bad7f9d44912d63be3d">UART_BIT_CFG</a>&#160;</td>
          <td class="paramname"><em>dmasa_en</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This register is use to perform DMA software acknowledge if a transfer needs to be terminated due to an error condition. </p>
<p>For example, if the DMA disables the channel, then uart should clear its request. This will cause the TX request, TX single, RX request and RX single signals to de-assert. </p><dl class="section note"><dt>Note</dt><dd>This bit is 'self-clearing' </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">uart_id</td><td>Identifies which UART to use </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dmasa_en</td><td>UART_BIT_CFG </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gafbe95da911950161c8ff2669875d19d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafbe95da911950161c8ff2669875d19d7">&#9670;&nbsp;</a></span>uart_enable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void uart_enable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structuart__t.html">uart_t</a> *&#160;</td>
          <td class="paramname"><em>uart_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable clock for UART peripheral. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">uart_id</td><td>Identifies which UART to use </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa252d4e13bd9d5274968a70bc1b88fd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa252d4e13bd9d5274968a70bc1b88fd9">&#9670;&nbsp;</a></span>uart_enable_flow_control()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void uart_enable_flow_control </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structuart__t.html">uart_t</a> *&#160;</td>
          <td class="paramname"><em>uart_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable UART flow control. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">uart_id</td><td>Identifies which UART to use. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaafa9d1b39105316d9a4029bc7145c297"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaafa9d1b39105316d9a4029bc7145c297">&#9670;&nbsp;</a></span>uart_fifo_enable_setf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_FORCEINLINE void uart_fifo_enable_setf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structuart__t.html">uart_t</a> *&#160;</td>
          <td class="paramname"><em>uart_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_a_r_t.html#ga1d34e34ab58c383449603db0b5cd4e89">UART_FIFO_CFG</a>&#160;</td>
          <td class="paramname"><em>fifo_en</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable/Disable UART FIFOs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">uart_id</td><td>Identifies which UART to use </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fifo_en</td><td>UART_FIFO_CFG </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga2196e40beecb150a770e6bc4b8cfca80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2196e40beecb150a770e6bc4b8cfca80">&#9670;&nbsp;</a></span>uart_fifo_enable_shd_setf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_FORCEINLINE void uart_fifo_enable_shd_setf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structuart__t.html">uart_t</a> *&#160;</td>
          <td class="paramname"><em>uart_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_a_r_t.html#ga1d34e34ab58c383449603db0b5cd4e89">UART_FIFO_CFG</a>&#160;</td>
          <td class="paramname"><em>fifo_en</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shadow FIFO Enable. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">uart_id</td><td>Identifies which UART to use </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fifo_en</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga2db7e6e6dc4f033750f80ca842f2ee50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2db7e6e6dc4f033750f80ca842f2ee50">&#9670;&nbsp;</a></span>uart_fifo_enabled_getf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_FORCEINLINE uint8_t uart_fifo_enabled_getf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structuart__t.html">uart_t</a> *&#160;</td>
          <td class="paramname"><em>uart_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indicate whether the FIFO's are enabled or disabled. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">uart_id</td><td>Identifies which UART to use </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>uint8_t UART_FIFO_CFG </dd></dl>

</div>
</div>
<a id="ga52e9b28a5175419dddf165030fcfe7a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga52e9b28a5175419dddf165030fcfe7a4">&#9670;&nbsp;</a></span>uart_fifo_rcvr_trg_setf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_FORCEINLINE void uart_fifo_rcvr_trg_setf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structuart__t.html">uart_t</a> *&#160;</td>
          <td class="paramname"><em>uart_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_a_r_t.html#ga56aaf477e65211c6e6858894d1590fd7">UART_RX_FIFO_LEVEL</a>&#160;</td>
          <td class="paramname"><em>rcvr_trigger</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the trigger level in the receiver FIFO at which the Received Data Available Interrupt will be generated. </p>
<p>In auto flow control mode it is used to determine when the rts_n signal will be de-asserted. It also determines when the dma_rx_req_n signal will be asserted when in certain modes of operation. The following trigger levels are supported: [00] = 1 character in the FIFO [01] = FIFO 1/4 full [10] = FIFO 1/2 full [11] = FIFO 2 less than full </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">uart_id</td><td>Identifies which UART to use </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rcvr_trigger</td><td>UART_RX_FIFO_LEVEL </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad5b542b18bc052f2c788d46bf606d241"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad5b542b18bc052f2c788d46bf606d241">&#9670;&nbsp;</a></span>uart_fifo_rcvr_trg_shd_setf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_FORCEINLINE void uart_fifo_rcvr_trg_shd_setf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structuart__t.html">uart_t</a> *&#160;</td>
          <td class="paramname"><em>uart_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_a_r_t.html#ga56aaf477e65211c6e6858894d1590fd7">UART_RX_FIFO_LEVEL</a>&#160;</td>
          <td class="paramname"><em>rcvr_trigger</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shadow RCVR Trigger. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">uart_id</td><td>Identifies which UART to use </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rcvr_trigger</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9514348aecbb204a0c3ee82bbe438e18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9514348aecbb204a0c3ee82bbe438e18">&#9670;&nbsp;</a></span>uart_fifo_txempty_trg_setf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_FORCEINLINE void uart_fifo_txempty_trg_setf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structuart__t.html">uart_t</a> *&#160;</td>
          <td class="paramname"><em>uart_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_a_r_t.html#ga10962da2c5916d3eb7890bab6ed7b3f4">UART_TX_FIFO_LEVEL</a>&#160;</td>
          <td class="paramname"><em>txempty_trigger</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the empty threshold level at which the THRE Interrupts will be generated when the mode is active. </p>
<p>It also determines when the dma_tx_req_n signal will be asserted when in certain modes of operation. The following trigger levels are supported: [00] = FIFO empty [01] = 2 characters in the FIFO [10] = FIFO 1/4 full [11] = FIFO 1/2 full </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">uart_id</td><td>Identifies which UART to use </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">txempty_trigger</td><td>UART_TX_FIFO_LEVEL </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga7b469dba7cf7febba432100782853bfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7b469dba7cf7febba432100782853bfe">&#9670;&nbsp;</a></span>uart_fifo_txempty_trg_shd_setf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_FORCEINLINE void uart_fifo_txempty_trg_shd_setf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structuart__t.html">uart_t</a> *&#160;</td>
          <td class="paramname"><em>uart_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_a_r_t.html#ga10962da2c5916d3eb7890bab6ed7b3f4">UART_TX_FIFO_LEVEL</a>&#160;</td>
          <td class="paramname"><em>txempty_trigger</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shadow TX Empty Trigger. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">uart_id</td><td>Identifies which UART to use </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">txempty_trigger</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa2ee484e01eb5a8ac34bbacc4580b3c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa2ee484e01eb5a8ac34bbacc4580b3c3">&#9670;&nbsp;</a></span>uart_finish_transfers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void uart_finish_transfers </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finish current UART1 transfers. </p>
<dl class="section note"><dt>Note</dt><dd>This function is implemented in ROM and cannot be combined with the SDK API for UART1. </dd></dl>

</div>
</div>
<a id="ga8fa6369dbfec69ec62ead02bd5bcfe53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8fa6369dbfec69ec62ead02bd5bcfe53">&#9670;&nbsp;</a></span>uart_flow_off()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool uart_flow_off </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disable UART1 flow control. </p>
<dl class="section note"><dt>Note</dt><dd>This function is implemented in ROM and cannot be combined with the SDK API for UART1. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>bool True if flow control has been successfully disabled. </dd></dl>

</div>
</div>
<a id="gaef16c430ef9a5c79ca1b15fc12d79133"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaef16c430ef9a5c79ca1b15fc12d79133">&#9670;&nbsp;</a></span>uart_flow_on()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void uart_flow_on </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable UART1 flow control. </p>
<dl class="section note"><dt>Note</dt><dd>This function is implemented in ROM and cannot be combined with the SDK API for UART1. </dd></dl>

</div>
</div>
<a id="gaabb0ffafed4c9aaefd185780e015428b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaabb0ffafed4c9aaefd185780e015428b">&#9670;&nbsp;</a></span>uart_halt_getf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_FORCEINLINE uint16_t uart_halt_getf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structuart__t.html">uart_t</a> *&#160;</td>
          <td class="paramname"><em>uart_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read Halt Transmit configuration. </p>
<p>This register is use to halt transmissions for testing, so that the transmit FIFO can be filled by the master when FIFOs are implemented and enabled. Note, if FIFOs are not enabled, the setting of the halt TX register has no effect on operation. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">uart_id</td><td>Identifies which UART to use </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>uint16_t 0 = Halt TX disabled, 1 = Halt TX enabled </dd></dl>

</div>
</div>
<a id="ga00659951dae871ec6787ef182318d9f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga00659951dae871ec6787ef182318d9f6">&#9670;&nbsp;</a></span>uart_halt_setf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_FORCEINLINE void uart_halt_setf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structuart__t.html">uart_t</a> *&#160;</td>
          <td class="paramname"><em>uart_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_a_r_t.html#gabd218b2905cb2bad7f9d44912d63be3d">UART_BIT_CFG</a>&#160;</td>
          <td class="paramname"><em>halt_en</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Halt Transmit. </p>
<p>This register is use to halt transmissions for testing, so that the transmit FIFO can be filled by the master when FIFOs are implemented and enabled. Note, if FIFOs are not enabled, the setting of the halt TX register has no effect on operation. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">uart_id</td><td>Identifies which UART to use </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">halt_en</td><td>UART_BIT_CFG </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga6249bc6884e59a75cdedc9099cf42eb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6249bc6884e59a75cdedc9099cf42eb4">&#9670;&nbsp;</a></span>uart_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void uart_init </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>baudr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dlf_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize UART1. </p>
<p>The following section exposes the API of the UART1 driver implemented in ROM. When the ROM UART1 driver is selected, it cannot be combined with the SDK API for UART1.</p>
<dl class="section note"><dt>Note</dt><dd>This function is implemented in ROM and cannot be combined with the SDK API for UART1. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">baudr</td><td>Baudrate Divisor Value </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dlf_value</td><td>Baudrate Fractional Value </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>Data bits mode </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gabdce908b80fca62f2b394bedc92e08a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabdce908b80fca62f2b394bedc92e08a5">&#9670;&nbsp;</a></span>uart_initialize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void uart_initialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structuart__t.html">uart_t</a> *&#160;</td>
          <td class="paramname"><em>uart_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structuart__cfg__t.html">uart_cfg_t</a> *&#160;</td>
          <td class="paramname"><em>uart_cfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize UART peripheral with custom settings. </p>
<p>This function initializes UART registers with given configuration. It also initializes all internal software variables for buffered transmissions. </p><dl class="section note"><dt>Note</dt><dd>In the case of DA14585/DA14586, the PD_PER domain shall be functional prior to UART initialization: SetBits16(PMU_CTRL_REG, PERIPH_SLEEP, 0); while (!(GetWord16(SYS_STAT_REG) &amp; PER_IS_UP)); </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">uart_id</td><td>Identifies which UART to use </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uart_cfg</td><td>UART configuration structure </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga16212753fd4720260baace0b1ef82303"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga16212753fd4720260baace0b1ef82303">&#9670;&nbsp;</a></span>uart_intr_config_getf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_FORCEINLINE uint8_t uart_intr_config_getf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structuart__t.html">uart_t</a> *&#160;</td>
          <td class="paramname"><em>uart_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get interrupt configuration of UART. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">uart_id</td><td>Identifies which UART to use </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>uint8_t Interrupt configuration </dd></dl>

</div>
</div>
<a id="ga62b972085a68612e3f2d303f4002ec19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga62b972085a68612e3f2d303f4002ec19">&#9670;&nbsp;</a></span>uart_intr_id_getf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_FORCEINLINE uint8_t uart_intr_id_getf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structuart__t.html">uart_t</a> *&#160;</td>
          <td class="paramname"><em>uart_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read Interrupt ID. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">uart_id</td><td>Identifies which UART to use </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>uint8_t Interrupt ID </dd></dl>

</div>
</div>
<a id="ga7b307ae2dd545073f568af8d7970438a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7b307ae2dd545073f568af8d7970438a">&#9670;&nbsp;</a></span>uart_is_busy_getf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_FORCEINLINE uint16_t uart_is_busy_getf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structuart__t.html">uart_t</a> *&#160;</td>
          <td class="paramname"><em>uart_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>UART Busy. </p>
<p>This indicates that a serial transfer is in progress, when cleared indicates that uart is idle or inactive. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">uart_id</td><td>Identifies which UART to use </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>uint16_t False = idle, True = busy </dd></dl>

</div>
</div>
<a id="gab3acbcedc0f268b7ef1bacc27accfba4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab3acbcedc0f268b7ef1bacc27accfba4">&#9670;&nbsp;</a></span>uart_lcr_setf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_FORCEINLINE void uart_lcr_setf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structuart__t.html">uart_t</a> *&#160;</td>
          <td class="paramname"><em>uart_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>lcr_val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a value to LCR. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">uart_id</td><td>Identifies which UART to use </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lcr_val</td><td>Value to write to LCR </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab498496ef1d433538067451ff4ca9051"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab498496ef1d433538067451ff4ca9051">&#9670;&nbsp;</a></span>uart_loopback_setf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_FORCEINLINE void uart_loopback_setf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structuart__t.html">uart_t</a> *&#160;</td>
          <td class="paramname"><em>uart_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_a_r_t.html#gabd218b2905cb2bad7f9d44912d63be3d">UART_BIT_CFG</a>&#160;</td>
          <td class="paramname"><em>lb_en</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable/Disable LoopBack. </p>
<p>Loopback mode shall be set before activating the pads or before setting the Baud Rate to ensure that UART module is not busy. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">uart_id</td><td>Identifies which UART to use </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lb_en</td><td>UART_BIT_CFG </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab4049d007b799bc0f3569b86d5dcd8bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab4049d007b799bc0f3569b86d5dcd8bb">&#9670;&nbsp;</a></span>uart_parity_getf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_FORCEINLINE uint16_t uart_parity_getf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structuart__t.html">uart_t</a> *&#160;</td>
          <td class="paramname"><em>uart_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get Parity configuration of UART. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">uart_id</td><td>Identifies which UART to use </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>UART_PARITY Parity configuration </dd></dl>

</div>
</div>
<a id="ga1ae77b84e60936544693b4e87b604ddd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1ae77b84e60936544693b4e87b604ddd">&#9670;&nbsp;</a></span>uart_parity_setf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_FORCEINLINE void uart_parity_setf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structuart__t.html">uart_t</a> *&#160;</td>
          <td class="paramname"><em>uart_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_a_r_t.html#ga24fd4dba815fc40fbd8e8c37dbf87c7a">UART_PARITY</a>&#160;</td>
          <td class="paramname"><em>parity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set Parity. </p>
<p>Writeable only when UART is not busy (USR0: is zero). It is used to enable and disable parity generation and detection in transmitted and received serial character respectively. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">uart_id</td><td>Identifies which UART to use </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">parity</td><td>UART_PARITY </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga2261e64ce574792337e9306fc8dbdfb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2261e64ce574792337e9306fc8dbdfb2">&#9670;&nbsp;</a></span>uart_read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void uart_read </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>bufptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(uint8_t)&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start data reception. </p>
<dl class="section note"><dt>Note</dt><dd>This function is implemented in ROM and cannot be combined with the SDK API for UART1. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">bufptr</td><td>Pointer to the RX buffer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Size of the expected reception </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">callback</td><td>Callback to return upon completion </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga53ee37e22077f15f4cd7687bec548bcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga53ee37e22077f15f4cd7687bec548bcb">&#9670;&nbsp;</a></span>uart_read_buffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void uart_read_buffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structuart__t.html">uart_t</a> *&#160;</td>
          <td class="paramname"><em>uart_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read number of bytes from UART. </p>
<p>This function is blocking, it waits to receive <code>len</code> bytes from UART. This function finishes when all data has been read from FIFO. This function does not use interrupts or DMA. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">uart_id</td><td>Identifies which UART to use </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">data</td><td>Pointer to the data buffer for incoming data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Number of bytes to read </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab665c813197eb77e836d27a314db37a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab665c813197eb77e836d27a314db37a5">&#9670;&nbsp;</a></span>uart_read_byte()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t uart_read_byte </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structuart__t.html">uart_t</a> *&#160;</td>
          <td class="paramname"><em>uart_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read one byte from UART. If FIFO is empty, it polls until received data are available. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">uart_id</td><td>Identifies which UART to use </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>read byte </dd></dl>

</div>
</div>
<a id="ga66d4c40771a984df9c75176d9673e291"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga66d4c40771a984df9c75176d9673e291">&#9670;&nbsp;</a></span>uart_read_rbr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_FORCEINLINE uint8_t uart_read_rbr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structuart__t.html">uart_t</a> *&#160;</td>
          <td class="paramname"><em>uart_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read a byte from Receive Buffer Register. </p>
<p>If FIFOs are enabled (FCR0: set to one), read the head of the receive FIFO. Contains the data byte received on the serial input port (sin) in UART mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">uart_id</td><td>Identifies which UART to use </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>uint8_t Value read from register </dd></dl>

</div>
</div>
<a id="ga01594693b105625d950cb8d234d4afb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga01594693b105625d950cb8d234d4afb6">&#9670;&nbsp;</a></span>uart_receive()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void uart_receive </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structuart__t.html">uart_t</a> *&#160;</td>
          <td class="paramname"><em>uart_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_a_r_t.html#ga69d334701827bc97a2c2753b4597d5db">UART_OP_CFG</a>&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start receiving data from UART receiver. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">uart_id</td><td>Identifies which UART to use </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">data</td><td>Data buffer to store received data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Number of bytes to receive </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">op</td><td>Blocking, interrupt-driven or DMA-driven operation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If a timeout error occurs during reception, it will fire the registerd error callback. </dd></dl>

</div>
</div>
<a id="ga0bc3887b353b90ca43f5860787bbc489"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0bc3887b353b90ca43f5860787bbc489">&#9670;&nbsp;</a></span>uart_register_err_cb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void uart_register_err_cb </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structuart__t.html">uart_t</a> *&#160;</td>
          <td class="paramname"><em>uart_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_a_r_t.html#ga54e57286e0cd5aa49304eff5ed78156c">uart_err_cb_t</a>&#160;</td>
          <td class="paramname"><em>cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register UART ERROR/STATYS callback (on-the-fly). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">uart_id</td><td>Identifies which UART to use </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb</td><td>pointer to callback of uart_cb_t type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga57fc914e051d99d433a0e8b75b8094c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga57fc914e051d99d433a0e8b75b8094c1">&#9670;&nbsp;</a></span>uart_register_rx_cb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void uart_register_rx_cb </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structuart__t.html">uart_t</a> *&#160;</td>
          <td class="paramname"><em>uart_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_a_r_t.html#ga587d4439909898b9ae38e9aca950ae02">uart_cb_t</a>&#160;</td>
          <td class="paramname"><em>cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register UART receive callback (on-the-fly). Callback to return in interrupt/DMA-driven receiving operations. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">uart_id</td><td>Identifies which UART to use </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb</td><td>pointer to callback of uart_cb_t type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0f742f5c61daeb943353cc4be7775f9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0f742f5c61daeb943353cc4be7775f9d">&#9670;&nbsp;</a></span>uart_register_tx_cb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void uart_register_tx_cb </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structuart__t.html">uart_t</a> *&#160;</td>
          <td class="paramname"><em>uart_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_a_r_t.html#ga587d4439909898b9ae38e9aca950ae02">uart_cb_t</a>&#160;</td>
          <td class="paramname"><em>cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register UART transmit callback (on-the-fly). Callback to return in interrupt/DMA-driven transmitting operations. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">uart_id</td><td>Identifies which UART to use </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb</td><td>pointer to callback of uart_cb_t type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf849ba8b9afad38bf677d8141dd9f2a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf849ba8b9afad38bf677d8141dd9f2a0">&#9670;&nbsp;</a></span>uart_rls_error_getf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_FORCEINLINE uint16_t uart_rls_error_getf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structuart__t.html">uart_t</a> *&#160;</td>
          <td class="paramname"><em>uart_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get RLS errors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">uart_id</td><td>Identifies which UART to use </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>uint16_t No error or error type </dd></dl>

</div>
</div>
<a id="ga48991de47b18c3f14a8ed62ac7b1036c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga48991de47b18c3f14a8ed62ac7b1036c">&#9670;&nbsp;</a></span>uart_rls_intr_setf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_FORCEINLINE void uart_rls_intr_setf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structuart__t.html">uart_t</a> *&#160;</td>
          <td class="paramname"><em>uart_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_a_r_t.html#gabd218b2905cb2bad7f9d44912d63be3d">UART_BIT_CFG</a>&#160;</td>
          <td class="paramname"><em>elsi_en</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable/Disable Receiver Line Status Interrupt This is used to enable/disable the generation of Receiver Line Status Interrupt. This is the highest priority interrupt. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">uart_id</td><td>Identifies which UART to use </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elsi_en</td><td>UART_BIT_CFG </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gabdf07dd559171e4e2bca3a1d02f365c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabdf07dd559171e4e2bca3a1d02f365c7">&#9670;&nbsp;</a></span>uart_rst_shd_setf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_FORCEINLINE void uart_rst_shd_setf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structuart__t.html">uart_t</a> *&#160;</td>
          <td class="paramname"><em>uart_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>UART Reset. </p>
<p>This asynchronously resets the UART Ctrl and synchronously removes the reset assertion. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">uart_id</td><td>Identifies which UART to use </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae815720f3e17a853544b927dfe7338b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae815720f3e17a853544b927dfe7338b0">&#9670;&nbsp;</a></span>uart_rts_shd_setf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_FORCEINLINE void uart_rts_shd_setf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structuart__t.html">uart_t</a> *&#160;</td>
          <td class="paramname"><em>uart_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_a_r_t.html#gabd218b2905cb2bad7f9d44912d63be3d">UART_BIT_CFG</a>&#160;</td>
          <td class="paramname"><em>uart_rts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shadow Request to Send. </p>
<p>This is a shadow register for the RTS bit (MCR[1]), this can be used to remove the burden of having to performing a read-modify-write on the MCR. This is used to directly control the Request to Send (rts_n) output. The Request To Send (rts_n) output is used to inform the modem or data set that the UART Ctrl is ready to exchange data. When Auto RTS Flow Control is not enabled (MCR[5] = 0), the rts_n signal is set low by programming MCR[1] (RTS) to a high. In Auto Flow Control, AFCE_MODE == Enabled and active (MCR[5] = 1) and FIFOs enable (FCR[0] = 1), the rts_n output is controlled in the same way, but is also gated with the receiver FIFO threshold trigger (rts_n is inactive high when above the threshold). Note that in Loopback mode (MCR[4] = 1), the rts_n output is held inactive-high while the value of this location is internally looped back to an input. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">uart_id</td><td>Identifies which UART to use </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uart_rts</td><td>UART_BIT_CFG </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaac120ac24dd850b520e7f3a07321b02f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaac120ac24dd850b520e7f3a07321b02f">&#9670;&nbsp;</a></span>uart_rtsn_setf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_FORCEINLINE void uart_rtsn_setf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structuart__t.html">uart_t</a> *&#160;</td>
          <td class="paramname"><em>uart_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_a_r_t.html#ga2a2e6711c13f801499299cf273a5e4e6">UART_AFCE_CFG</a>&#160;</td>
          <td class="paramname"><em>rts_n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable/Disable Request to Send. </p>
<p>This is used to directly control the Request to Send (rts_n) output.</p>
<dl class="section note"><dt>Note</dt><dd>HW flowcontrol is not supported in UART2 of DA14531</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">uart_id</td><td>Identifies which UART to use </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rts_n</td><td>0: disabled, 1: enabled </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa4c3158f343f17b0097155962160e58c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa4c3158f343f17b0097155962160e58c">&#9670;&nbsp;</a></span>uart_rxdata_intr_setf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_FORCEINLINE void uart_rxdata_intr_setf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structuart__t.html">uart_t</a> *&#160;</td>
          <td class="paramname"><em>uart_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_a_r_t.html#gabd218b2905cb2bad7f9d44912d63be3d">UART_BIT_CFG</a>&#160;</td>
          <td class="paramname"><em>erbfi_en</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable/Disable Received Data Available Interrupt. </p>
<p>This is used to enable/disable the generation of Received Data Available Interrupt and the Character Timeout Interrupt (if in FIFO mode and FIFO's enabled). These are the second highest priority interrupts.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">uart_id</td><td>Identifies which UART to use </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">erbfi_en</td><td>UART_BIT_CFG </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3142f530691ced4991360d109b6bde6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3142f530691ced4991360d109b6bde6e">&#9670;&nbsp;</a></span>uart_rxfifo_flush()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_FORCEINLINE void uart_rxfifo_flush </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structuart__t.html">uart_t</a> *&#160;</td>
          <td class="paramname"><em>uart_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reset the control portion of the receive FIFO and treats the FIFO as empty. </p>
<dl class="section note"><dt>Note</dt><dd>This bit is 'self-clearing' and it is not necessary to clear it. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">uart_id</td><td>Identifies which UART to use </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaab55514b096939cb90732f0cd1b00abf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaab55514b096939cb90732f0cd1b00abf">&#9670;&nbsp;</a></span>uart_rxfifo_flush_shd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_FORCEINLINE void uart_rxfifo_flush_shd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structuart__t.html">uart_t</a> *&#160;</td>
          <td class="paramname"><em>uart_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>RCVR FIFO Reset. </p>
<p>This is a shadow register for the RCVR FIFO Reset bit (FCR1:). This can be used to remove the burden on software having to store previously written FCR values (which are pretty static) just to reset the receive FIFO This resets the control portion of the receive FIFO and treats the FIFO as empty. This bit is 'self-clearing'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">uart_id</td><td>Identifies which UART to use </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac605b798d0411d9246c5fe9b93da4c72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac605b798d0411d9246c5fe9b93da4c72">&#9670;&nbsp;</a></span>uart_rxfifo_is_full_getf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_FORCEINLINE uint16_t uart_rxfifo_is_full_getf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structuart__t.html">uart_t</a> *&#160;</td>
          <td class="paramname"><em>uart_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Receive FIFO Full. </p>
<p>This is used to indicate that the receive FIFO is completely full. This bit is cleared when the RX FIFO is no longer full. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">uart_id</td><td>Identifies which UART to use </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>uint16_t 0 = Receive FIFO not full, 1 = Receive FIFO Full </dd></dl>

</div>
</div>
<a id="ga90ca512ff8ff50986758f24ec36a8712"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga90ca512ff8ff50986758f24ec36a8712">&#9670;&nbsp;</a></span>uart_rxfifo_level_getf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_FORCEINLINE uint16_t uart_rxfifo_level_getf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structuart__t.html">uart_t</a> *&#160;</td>
          <td class="paramname"><em>uart_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Receive FIFO Level. </p>
<p>This is indicates the number of data entries in the receive FIFO. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">uart_id</td><td>Identifies which UART to use </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>uint16_t Data entries </dd></dl>

</div>
</div>
<a id="ga3fc4e229be420bc1edca175df1b8e6dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3fc4e229be420bc1edca175df1b8e6dc">&#9670;&nbsp;</a></span>uart_rxfifo_not_empty_getf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_FORCEINLINE uint16_t uart_rxfifo_not_empty_getf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structuart__t.html">uart_t</a> *&#160;</td>
          <td class="paramname"><em>uart_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Receive FIFO Not Empty. </p>
<p>This is used to indicate that the receive FIFO contains one or more entries. This bit is cleared when the RX FIFO is empty. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">uart_id</td><td>Identifies which UART to use </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>uint16_t 0 = Receive FIFO is empty, 1 = Receive FIFO is not empty </dd></dl>

</div>
</div>
<a id="ga1733e3fc1c5add13047e239e20bd666e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1733e3fc1c5add13047e239e20bd666e">&#9670;&nbsp;</a></span>uart_scr_reg_getf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_FORCEINLINE uint16_t uart_scr_reg_getf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structuart__t.html">uart_t</a> *&#160;</td>
          <td class="paramname"><em>uart_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This register is for programmers to use as a temporary storage space. </p>
<dl class="section note"><dt>Note</dt><dd>It has no defined purpose in the UART CTRL. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">uart_id</td><td>Identifies which UART to use </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>uint16_t read byte </dd></dl>

</div>
</div>
<a id="ga5a4a5208838782dc2697814a9aabfe1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5a4a5208838782dc2697814a9aabfe1b">&#9670;&nbsp;</a></span>uart_scr_reg_setf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_FORCEINLINE void uart_scr_reg_setf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structuart__t.html">uart_t</a> *&#160;</td>
          <td class="paramname"><em>uart_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This register is for programmers to use as a temporary storage space. </p>
<dl class="section note"><dt>Note</dt><dd>It has no defined purpose in the UART CTRL. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">uart_id</td><td>Identifies which UART to use </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Byte to write </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga7bab515ae0edd81cca4095ca2a73e7d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7bab515ae0edd81cca4095ca2a73e7d8">&#9670;&nbsp;</a></span>uart_send()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void uart_send </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structuart__t.html">uart_t</a> *&#160;</td>
          <td class="paramname"><em>uart_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_a_r_t.html#ga69d334701827bc97a2c2753b4597d5db">UART_OP_CFG</a>&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start sending data to UART transmitter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">uart_id</td><td>Identifies which UART to use </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Pointer to data buffer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Length (bytes) of data buffer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">op</td><td>Blocking, interrupt-driven or DMA-driven operation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga051c5642c97eb38c5c8f5b7b8da22fa2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga051c5642c97eb38c5c8f5b7b8da22fa2">&#9670;&nbsp;</a></span>uart_set_flow_off_retries_limit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void uart_set_flow_off_retries_limit </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>limit</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the limit of retries to disable flow control. </p>
<dl class="section note"><dt>Note</dt><dd>This function is implemented in ROM and cannot be combined with the SDK API for UART1. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">limit</td><td>Maximum number of retries </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga24764f0482c63b02067bf3d8e24f4a00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga24764f0482c63b02067bf3d8e24f4a00">&#9670;&nbsp;</a></span>uart_sire_setf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_FORCEINLINE void uart_sire_setf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structuart__t.html">uart_t</a> *&#160;</td>
          <td class="paramname"><em>uart_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_a_r_t.html#gabd218b2905cb2bad7f9d44912d63be3d">UART_BIT_CFG</a>&#160;</td>
          <td class="paramname"><em>sire</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable/Disable SIR Mode. </p>
<p>This is used to enable/disable the IrDA SIR Mode features as described in IrDA 1.0 SIR Protocol. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">uart_id</td><td>Identifies which UART to use </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sire</td><td>0: IrDA SIR Mode disabled, 1: IrDA SIR Mode enabled </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>SIR Mode is not supported in DA14531 </dd></dl>

</div>
</div>
<a id="ga0bfc37843697051566ae688fb2adffe8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0bfc37843697051566ae688fb2adffe8">&#9670;&nbsp;</a></span>uart_stop_bits_getf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_FORCEINLINE uint16_t uart_stop_bits_getf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structuart__t.html">uart_t</a> *&#160;</td>
          <td class="paramname"><em>uart_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get stop bits configuration of UART. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">uart_id</td><td>Identifies which UART to use </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>UART_STOPBITS Stop bits configuration </dd></dl>

</div>
</div>
<a id="ga501e17f226a93522e44ddec3b186d700"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga501e17f226a93522e44ddec3b186d700">&#9670;&nbsp;</a></span>uart_stop_bits_setf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_FORCEINLINE void uart_stop_bits_setf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structuart__t.html">uart_t</a> *&#160;</td>
          <td class="paramname"><em>uart_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_a_r_t.html#gacbd51ac613ec824eeb73a5b6bf743ca6">UART_STOPBITS</a>&#160;</td>
          <td class="paramname"><em>stop_bits</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set number of stop bits. </p>
<p>This is used to select the number of stop bits per character that the peripheral transmits and receives. If set to zero, one stop bit is transmitted in the serial data. If set to one and the data bits are set to 5 (LCR[1:0] set to zero) one and a half stop bits is transmitted. Otherwise, two stop bits are transmitted. Note that regardless of the number of stop bits selected, the receiver checks only the first stop bit. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">uart_id</td><td>Identifies which UART to use </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stop_bits</td><td>UART_STOPBITS </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga2755364dfcc21b7aa67c0a9232e0fe0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2755364dfcc21b7aa67c0a9232e0fe0a">&#9670;&nbsp;</a></span>uart_thr_empty_getf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_FORCEINLINE uint16_t uart_thr_empty_getf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structuart__t.html">uart_t</a> *&#160;</td>
          <td class="paramname"><em>uart_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transmit Holding Register Empty bit. </p>
<p>If THRE mode is disabled (IER[7] =0) and regardless of FIFO's being enabled or not, this bit indicates that the THR or TX FIFO is empty. This bit is set whenever data is transferred from the THR or TX FIFO to the transmitter shift register and no new data has been written to the THR or TX FIFO. This also causes a THRE Interrupt to occur, if the THRE Interrupt is enabled. If both modes are active (IER[7] =1 and FCR0: =1 respectively), the functionality is switched to indicate the transmitter FIFO is full, and no longer controls THRE interrupts, which are then controlled by the FCR[5:4] threshold setting. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">uart_id</td><td>Identifies which UART to use </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>uint16_t 0 = not empty / not full, 1 = empty / full </dd></dl>

</div>
</div>
<a id="ga3a22444176246b6a3ac548619978d63a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3a22444176246b6a3ac548619978d63a">&#9670;&nbsp;</a></span>uart_thr_setf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_FORCEINLINE void uart_thr_setf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structuart__t.html">uart_t</a> *&#160;</td>
          <td class="paramname"><em>uart_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write byte to Transmit Holding Register. </p>
<p>If FIFOs are enabled (FCR0: set to one), write byte to the transmit FIFO. This register contains data to be transmitted on the serial output port (sout) in UART mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">uart_id</td><td>Identifies which UART to use </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Byte to write </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga473fd4ca23ddca3314e26a6ea8895e68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga473fd4ca23ddca3314e26a6ea8895e68">&#9670;&nbsp;</a></span>uart_thre_intr_setf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_FORCEINLINE void uart_thre_intr_setf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structuart__t.html">uart_t</a> *&#160;</td>
          <td class="paramname"><em>uart_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_a_r_t.html#gabd218b2905cb2bad7f9d44912d63be3d">UART_BIT_CFG</a>&#160;</td>
          <td class="paramname"><em>ptime_en</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable/Disable Programmable THRE Interrupt Mode. </p>
<p>This is used to enable/disable the generation of THRE Interrupt. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">uart_id</td><td>Identifies which UART to use </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ptime_en</td><td>UART_BIT_CFG </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gada0a473feaf9b949d0ba442a652b6de3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gada0a473feaf9b949d0ba442a652b6de3">&#9670;&nbsp;</a></span>uart_tx_empty_getf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_FORCEINLINE uint16_t uart_tx_empty_getf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structuart__t.html">uart_t</a> *&#160;</td>
          <td class="paramname"><em>uart_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transmitter Empty bit. </p>
<p>If FIFOs enabled (FCR0: =1), this bit is set whenever the Transmitter Shift Register and the FIFO are both empty. If FIFOs are disabled, this bit is set whenever the Transmitter Holding Register and the Transmitter Shift Register are both empty. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">uart_id</td><td>Identifies which UART to use </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>uint16_t 0 = not empty, 1 = empty </dd></dl>

</div>
</div>
<a id="ga3f0bed0a96e6768774085f5beb77c165"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3f0bed0a96e6768774085f5beb77c165">&#9670;&nbsp;</a></span>uart_txdata_intr_setf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_FORCEINLINE void uart_txdata_intr_setf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structuart__t.html">uart_t</a> *&#160;</td>
          <td class="paramname"><em>uart_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_a_r_t.html#gabd218b2905cb2bad7f9d44912d63be3d">UART_BIT_CFG</a>&#160;</td>
          <td class="paramname"><em>etbei_en</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable/Disable Transmit Holding Register Empty Interrupt. </p>
<p>This is used to enable/disable the generation of Transmitter Holding Register Empty Interrupt. This is the third highest priority interrupt.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">uart_id</td><td>Identifies which UART to use </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">etbei_en</td><td>UART_BIT_CFG </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga410d21f5c87e70f3e83911c0d3762d8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga410d21f5c87e70f3e83911c0d3762d8c">&#9670;&nbsp;</a></span>uart_txfifo_flush()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_FORCEINLINE void uart_txfifo_flush </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structuart__t.html">uart_t</a> *&#160;</td>
          <td class="paramname"><em>uart_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reset the control portion of the transmit FIFO and treats the FIFO as empty. </p>
<dl class="section note"><dt>Note</dt><dd>This bit is 'self-clearing' and it is not necessary to clear it. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">uart_id</td><td>Identifies which UART to use </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac1e12e30412b38e43230d111b2e10f20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac1e12e30412b38e43230d111b2e10f20">&#9670;&nbsp;</a></span>uart_txfifo_flush_shd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_FORCEINLINE void uart_txfifo_flush_shd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structuart__t.html">uart_t</a> *&#160;</td>
          <td class="paramname"><em>uart_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>XMIT FIFO Reset. </p>
<p>This is a shadow register for the XMIT FIFO Reset bit (FCR[2]). This can be used to remove the burden on software having to store previously written FCR values (which are pretty static) just to reset the transmit FIFO. This resets the control portion of the transmit FIFO and treats the FIFO as empty. This bit is 'self-clearing'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">uart_id</td><td>Identifies which UART to use </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac1928af7c7dcbec8d66cf8fbc82a8b23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac1928af7c7dcbec8d66cf8fbc82a8b23">&#9670;&nbsp;</a></span>uart_txfifo_is_empty_getf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_FORCEINLINE uint16_t uart_txfifo_is_empty_getf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structuart__t.html">uart_t</a> *&#160;</td>
          <td class="paramname"><em>uart_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transmit FIFO Empty. </p>
<p>This is used to indicate that the transmit FIFO is completely empty. This bit is cleared when the TX FIFO is no longer empty. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">uart_id</td><td>Identifies which UART to use </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>uint16_t False = Transmit FIFO is not empty, True = Transmit FIFO is empty </dd></dl>

</div>
</div>
<a id="ga1107af4317dfb647fdf8c733e42810db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1107af4317dfb647fdf8c733e42810db">&#9670;&nbsp;</a></span>uart_txfifo_level_getf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_FORCEINLINE uint16_t uart_txfifo_level_getf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structuart__t.html">uart_t</a> *&#160;</td>
          <td class="paramname"><em>uart_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transmit FIFO Level. </p>
<p>This is indicates the number of data entries in the transmit FIFO. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">uart_id</td><td>Identifies which UART to use </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>uint16_t Data entries </dd></dl>

</div>
</div>
<a id="gafd8c121219523de286d063023af76f6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafd8c121219523de286d063023af76f6d">&#9670;&nbsp;</a></span>uart_txfifo_not_full_getf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_FORCEINLINE uint16_t uart_txfifo_not_full_getf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structuart__t.html">uart_t</a> *&#160;</td>
          <td class="paramname"><em>uart_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transmit FIFO Not Full. </p>
<p>This is used to indicate that the transmit FIFO in not full. This bit is cleared when the TX FIFO is full. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">uart_id</td><td>Identifies which UART to use </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>uint16_t 0: Transmit FIFO is full, 1: Transmit FIFO is not full </dd></dl>

</div>
</div>
<a id="ga9473f9474d6613c9a187259008075b2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9473f9474d6613c9a187259008075b2e">&#9670;&nbsp;</a></span>uart_wait_tx_finish()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void uart_wait_tx_finish </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structuart__t.html">uart_t</a> *&#160;</td>
          <td class="paramname"><em>uart_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait until UART has finished all transfers. </p>
<p>If FIFOs are enabled, the function waits until the Transmitter Shift Register and the FIFO are both empty. If FIFOs are disabled, it waits until the Transmitter Holding Register and the Transmitter Shift Register are both empty. This function must be called after the transmit callback is fired to ensure that all data have been sent, i.e. before going to sleep.</p>
<dl class="section note"><dt>Note</dt><dd>This function is blocking and must not be called inside the driver's tx isr or the user tx callback in full-duplex UART transfers, to avoid missing reception interrupts.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">uart_id</td><td>Identifies which UART to use </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9372a2be5a36dfa309be4f154b0dd590"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9372a2be5a36dfa309be4f154b0dd590">&#9670;&nbsp;</a></span>uart_write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void uart_write </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>bufptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(uint8_t)&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start data transmission. </p>
<dl class="section note"><dt>Note</dt><dd>This function is implemented in ROM and cannot be combined with the SDK API for UART1. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bufptr</td><td>Pointer to the TX buffer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Size of the transmission </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">callback</td><td>Callback to return upon completion </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac852018305c0a03156ee9c7d20eb592d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac852018305c0a03156ee9c7d20eb592d">&#9670;&nbsp;</a></span>uart_write_buffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void uart_write_buffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structuart__t.html">uart_t</a> *&#160;</td>
          <td class="paramname"><em>uart_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a number of bytes to UART. </p>
<p>This function is blocking, it finishes when all data has been written in FIFO. It does not wait for data to be transmitted out from UART. This function does not use interrupts or DMA. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">uart_id</td><td>Identifies which UART to use </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Pointer to data buffer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Length (bytes) of data buffer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9038578a8bf8750edaa312278d5c8162"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9038578a8bf8750edaa312278d5c8162">&#9670;&nbsp;</a></span>uart_write_byte()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void uart_write_byte </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structuart__t.html">uart_t</a> *&#160;</td>
          <td class="paramname"><em>uart_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write one byte to UART. </p>
<p>Writes one byte in Tx FIFO. If FIFO is full, it will wait until it has free space, according to the configured threshold level. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">uart_id</td><td>Identifies which UART to use </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Byte to write </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ga7860982304013a9e0914fdd360b283ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7860982304013a9e0914fdd360b283ea">&#9670;&nbsp;</a></span>rts_uart_pin</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t ext_wkup_uart_pins_t::rts_uart_pin</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga3125e5fec9a103b1cbf0dfce566621e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3125e5fec9a103b1cbf0dfce566621e3">&#9670;&nbsp;</a></span>rts_uart_port</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t ext_wkup_uart_pins_t::rts_uart_port</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri May 9 2025 12:55:40 for DA14585/DA14586 SDK6 by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
